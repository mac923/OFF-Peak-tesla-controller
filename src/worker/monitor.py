#!/usr/bin/env python3
"""
Cloud Tesla Monitor - Inteligentne monitorowanie pojazdu Tesla w Google Cloud
System ciƒÖg≈Çego monitorowania z logowaniem tylko zmian stanu.

NOWA ARCHITEKTURA OPTYMALIZACJI KOSZT√ìW:
- Domy≈õlny tryb: Cloud Scheduler + Cloud Run "scale-to-zero" (optymalizacja koszt√≥w)
- Tryb fallback: CiƒÖg≈Çe dzia≈Çanie (poprzednia implementacja)
- Zachowana pe≈Çna funkcjonalno≈õƒá Smart Proxy Mode

Harmonogram (UTC):
- 07:00-23:00: sprawdzaj co 15 minut
- 23:00-07:00: sprawdzaj co 60 minut
- 00:00: jednorazowe wybudzenie pojazdu i sprawdzenie stanu

NOWA Logika monitorowania (v2):
- System ZAWSZE monitoruje pojazd w regularnych interwa≈Çach
- Loguje tylko ZMIANY stanu, nie powtarzajƒÖce siƒô informacje
- WARUNEK A (gotowy do ≈Çadowania w domu): loguj pierwsze wykrycie + wywo≈Çaj OFF PEAK CHARGE API
- WARUNEK B (niegotowy w domu): loguj zmianƒô z gotowego na niegotowy
- Przyjazd/wyjazd z domu: zawsze loguj
- Przej≈õcie online/offline: zawsze loguj
- Inne stany: nie loguj, chyba ≈ºe zmiana

NOWA Funkcjonalno≈õƒá - Automatyczne zarzƒÖdzanie harmonogramami ≈Çadowania:
- Po pobraniu harmonogramu z OFF PEAK CHARGE API sprawdza czy jest r√≥≈ºny od poprzedniego
- Je≈õli jest r√≥≈ºny: usuwa stare harmonogramy HOME i wysy≈Ça nowe z API OFF PEAK CHARGE
- Wymaga Tesla HTTP Proxy dla wysy≈Çania komend do pojazdu

OPTYMALIZACJA KOSZT√ìW:
- Cloud Scheduler wywo≈Çuje endpoint /run-cycle co 15/60 minut
- Cloud Run skaluje do zera miƒôdzy wywo≈Çaniami
- Tryb ciƒÖg≈Çy dostƒôpny jako fallback (zmienna CONTINUOUS_MODE=true)

Korzy≈õci:
‚úÖ CiƒÖg≈Çe monitorowanie - nie gubi zmian stanu
‚úÖ Minimalne logowanie - tylko istotne wydarzenia  
‚úÖ ≈öledzenie historii zmian stanu pojazdu
‚úÖ Lepsze debugowanie i diagnostyka
‚úÖ Integracja z OFF PEAK CHARGE API dla optymalizacji ≈Çadowania
‚úÖ Automatyczne zarzƒÖdzanie harmonogramami ≈Çadowania
‚úÖ Optymalizacja koszt√≥w Cloud Run (scale-to-zero)

Wymagane sekrety w Google Cloud Secret Manager dla OFF PEAK CHARGE API:
- OFF_PEAK_CHARGE_API_URL: URL do API (opcjonalny, domy≈õlnie: http://localhost:3000/api/external-calculate)
- OFF_PEAK_CHARGE_API_KEY: Klucz autoryzacyjny dla API (wymagany)
"""

import os
import json
import time
import logging
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import asyncio
import schedule
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
import pytz
import requests
from google.cloud import logging as cloud_logging
from google.cloud import storage
from google.cloud import firestore
from dotenv import load_dotenv
from src.core.tesla_controller import TeslaController, ChargeSchedule
from src.core.tesla_fleet_api_client import TeslaAuthenticationError
from google.cloud import secretmanager
# BEZPIECZE≈ÉSTWO: Wy≈ÇƒÖczenie ostrze≈ºe≈Ñ SSL dla Tesla HTTP Proxy
# Tesla HTTP Proxy (localhost) u≈ºywa self-signed certyfikat√≥w SSL
# To jest bezpieczne poniewa≈º:
# 1. Komunikacja odbywa siƒô lokalnie (localhost/127.0.0.1)
# 2. Tesla HTTP Proxy jest zaufanym komponentem
# 3. Self-signed certyfikaty sƒÖ standardem dla lokalnych proxy
# 4. Dane sƒÖ ju≈º szyfrowane przez Tesla Fleet API na wy≈ºszym poziomie
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Konfiguracja Google Cloud Logging
if os.getenv('GOOGLE_CLOUD_PROJECT'):
    client = cloud_logging.Client()
    client.setup_logging()

# Standardowe logowanie
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# BEZPIECZE≈ÉSTWO: Informacje o konfiguracji SSL
logger.info("üîí BEZPIECZE≈ÉSTWO: Wy≈ÇƒÖczono ostrze≈ºenia SSL urllib3 dla Tesla HTTP Proxy")
logger.info("üîí Dotyczy tylko localhost z self-signed certyfikatami - bezpiecze≈Ñstwo zachowane")

def get_secret(secret_name: str, project_id: str) -> Optional[str]:
    """
    Odczytuje sekret z Google Secret Manager
    
    Args:
        secret_name: Nazwa sekretu
        project_id: ID projektu Google Cloud
        
    Returns:
        Warto≈õƒá sekretu lub None je≈õli b≈ÇƒÖd
    """
    try:
        client = secretmanager.SecretManagerServiceClient()
        name = f"projects/{project_id}/secrets/{secret_name}/versions/latest"
        response = client.access_secret_version(request={"name": name})
        return response.payload.data.decode("UTF-8")
    except Exception as e:
        logger.warning(f"Nie mo≈ºna odczytaƒá sekretu {secret_name}: {e}")
        return None

def _log_simple_status(status: Dict[str, Any], action: str = "") -> None:
    """
    Loguje prosty status pojazdu w formacie: [HH:MM] ‚úÖ VIN=xxx, bateria=xx%, ≈Çadowanie=xxx, lokalizacja=xxx
    
    Args:
        status: S≈Çownik ze statusem pojazdu
        action: Opcjonalny opis akcji (np. "wake-up", "check")
    """
    try:
        # Czas warszawski w formacie [HH:MM]
        warsaw_tz = pytz.timezone('Europe/Warsaw')
        now = datetime.now(warsaw_tz)
        time_str = now.strftime("[%H:%M]")
        
        # Podstawowe dane pojazdu
        vin = status.get('vin', 'Unknown')
        vin_short = vin[-4:] if len(vin) > 4 else vin
        battery = status.get('battery_level', 0)
        is_charging_ready = status.get('is_charging_ready', False)
        location = status.get('location_status', 'UNKNOWN')
        is_online = status.get('online', False)
        
        # Formatowanie statusu ≈Çadowania
        charging_status = "gotowe" if is_charging_ready else "niegotowe"
        
        # Emoji w zale≈ºno≈õci od stanu online
        emoji = "‚úÖ" if is_online else "‚ùå"
        
        # Formatowanie loga
        if action:
            log_msg = f"{time_str} {emoji} {action} - VIN={vin_short}, bateria={battery}%, ≈Çadowanie={charging_status}, lokalizacja={location}"
        else:
            log_msg = f"{time_str} {emoji} VIN={vin_short}, bateria={battery}%, ≈Çadowanie={charging_status}, lokalizacja={location}"
        
        logger.info(log_msg)
        
    except Exception as e:
        logger.error(f"B≈ÇƒÖd logowania prostego statusu: {e}")

class HealthCheckHandler(BaseHTTPRequestHandler):
    """Handler dla endpoint'√≥w aplikacji"""
    
    def __init__(self, monitor_instance, *args, **kwargs):
        self.monitor = monitor_instance
        super().__init__(*args, **kwargs)
    
    def do_GET(self):
        """Obs≈Çuguje ≈ºƒÖdania GET"""
        if self.path == '/health':
            self._handle_health_check()
        elif self.path == '/reset':
            self._handle_reset()
        elif self.path == '/reset-tesla-schedules':
            self._handle_reset_tesla_schedules()
        elif self.path == '/debug-env':
            self._handle_debug_env()
        else:
            self.send_response(404)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'Not found')
    
    def do_POST(self):
        """Obs≈Çuguje POST request"""
        if self.path == '/run-cycle':
            self._handle_run_cycle()
        elif self.path == '/run-midnight-wake':
            self._handle_midnight_wake()
        else:
            self.send_response(404)
            self.end_headers()
    
    def _handle_health_check(self):
        """Obs≈Çuguje sprawdzenie stanu aplikacji"""
        try:
            warsaw_time = self.monitor._get_warsaw_time()
            
            # Sprawd≈∫ aktywne przypadki monitorowania
            active_cases_count = len(self.monitor.active_cases)
            
            response = {
                'status': 'healthy',
                'is_running': True,
                'active_cases': active_cases_count,
                'timestamp': warsaw_time.isoformat(),
                'timezone': 'Europe/Warsaw',
                'mode': 'scheduler'
            }
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(response, ensure_ascii=False, indent=2).encode('utf-8'))
            
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd health check: {e}")
            
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
            
            self.wfile.write(json.dumps(response).encode())

    def _handle_debug_env(self):
        """Obs≈Çuguje diagnostykƒô zmiennych ≈õrodowiskowych Smart Proxy Mode"""
        try:
            warsaw_time = self.monitor._get_warsaw_time()
            
            response = {
                'timestamp': warsaw_time.isoformat(),
                'timezone': 'Europe/Warsaw',
                'environment_variables': {
                    'TESLA_SMART_PROXY_MODE': os.getenv('TESLA_SMART_PROXY_MODE'),
                    'TESLA_PROXY_AVAILABLE': os.getenv('TESLA_PROXY_AVAILABLE'),
                    'TESLA_HTTP_PROXY_HOST': os.getenv('TESLA_HTTP_PROXY_HOST'),
                    'TESLA_HTTP_PROXY_PORT': os.getenv('TESLA_HTTP_PROXY_PORT')
                },
                'monitor_state': {
                    'smart_proxy_mode': self.monitor.smart_proxy_mode,
                    'proxy_available': self.monitor.proxy_available,
                    'proxy_running': self.monitor.proxy_running
                },
                'debug_info': {
                    'smart_proxy_check': os.getenv('TESLA_SMART_PROXY_MODE') == 'true',
                    'proxy_available_check': os.getenv('TESLA_PROXY_AVAILABLE') == 'true'
                }
            }
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(response, ensure_ascii=False, indent=2).encode('utf-8'))
            
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd debug env: {e}")
            
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'error',
                'error': str(e)
            }
            
            self.wfile.write(json.dumps(response).encode())
    
    def _handle_reset(self):
        """Obs≈Çuguje reset stanu monitorowania"""
        try:
            reset_result = self.monitor.reset_all_monitoring_state()
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'reset_completed',
                'message': 'Monitoring state reset successfully - ready for testing from scratch',
                'reset_details': reset_result,
                'next_steps': [
                    'Application will now detect all vehicle states as new',
                    'First OFF PEAK CHARGE API call will be treated as initial',
                    'All harmonogram changes will be logged as first-time events'
                ]
            }
            
            self.wfile.write(json.dumps(response, ensure_ascii=False, indent=2).encode('utf-8'))
        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'reset_failed',
                'error': str(e),
                'timestamp': datetime.now().isoformat(),
                'timezone': 'Europe/Warsaw'
            }
            
            self.wfile.write(json.dumps(response).encode())
    
    def _handle_reset_tesla_schedules(self):
        """Obs≈Çuguje reset harmonogram√≥w Tesla"""
        try:
            reset_result = self.monitor.reset_tesla_home_schedules()
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'tesla_schedules_reset_completed' if reset_result.get('success') else 'tesla_schedules_reset_failed',
                'message': 'Tesla HOME schedules reset completed - all HOME schedules removed' if reset_result.get('success') else 'Tesla HOME schedules reset failed',
                'reset_details': reset_result,
                'next_steps': [
                    'All HOME schedules have been removed from Tesla',
                    'New schedules will be added based on OFF PEAK CHARGE API data',
                    'Monitor vehicle for new charging schedule events'
                ] if reset_result.get('success') else [
                    'Check Tesla HTTP Proxy availability',
                    'Verify Tesla API authorization',
                    'Try manual schedule removal through Tesla app'
                ]
            }
            
            self.wfile.write(json.dumps(response, ensure_ascii=False, indent=2).encode('utf-8'))
        except Exception as e:
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'tesla_schedules_reset_error',
                'error': str(e),
                'timestamp': datetime.now().isoformat(),
                'timezone': 'Europe/Warsaw'
            }
            
            self.wfile.write(json.dumps(response).encode())
    
    def _handle_run_cycle(self):
        """Obs≈Çuguje wywo≈Çanie cyklu monitorowania przez Cloud Scheduler"""
        try:
            warsaw_time = self.monitor._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            
            logger.info(f"{time_str} üìÖ Cloud Scheduler: Rozpoczƒôcie cyklu monitorowania")
            
            # Wykonaj cykl monitorowania
            self.monitor.run_monitoring_cycle()
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'cycle_completed',
                'message': 'Monitoring cycle completed successfully',
                'timestamp': warsaw_time.isoformat(),
                'timezone': 'Europe/Warsaw',
                'trigger': 'cloud_scheduler'
            }
            
            logger.info(f"{time_str} ‚úÖ Cloud Scheduler: Cykl monitorowania zako≈Ñczony")
            
            self.wfile.write(json.dumps(response, ensure_ascii=False, indent=2).encode('utf-8'))
            
        except Exception as e:
            warsaw_time = self.monitor._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            
            logger.error(f"{time_str} ‚ùå Cloud Scheduler: B≈ÇƒÖd cyklu monitorowania: {e}")
            
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'cycle_failed',
                'error': str(e),
                'timestamp': warsaw_time.isoformat(),
                'timezone': 'Europe/Warsaw',
                'trigger': 'cloud_scheduler'
            }
            
            self.wfile.write(json.dumps(response).encode())
    
    def _handle_midnight_wake(self):
        """Obs≈Çuguje nocne wybudzenie pojazdu przez Cloud Scheduler"""
        try:
            warsaw_time = self.monitor._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            
            logger.info(f"{time_str} üåô Cloud Scheduler: Rozpoczƒôcie nocnego wybudzenia")
            
            # Wykonaj nocne wybudzenie
            self.monitor.run_midnight_wake_check()
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'midnight_wake_completed',
                'message': 'Midnight wake check completed successfully',
                'timestamp': warsaw_time.isoformat(),
                'timezone': 'Europe/Warsaw',
                'trigger': 'cloud_scheduler'
            }
            
            logger.info(f"{time_str} ‚úÖ Cloud Scheduler: Nocne wybudzenie zako≈Ñczone")
            
            self.wfile.write(json.dumps(response, ensure_ascii=False, indent=2).encode('utf-8'))
            
        except Exception as e:
            warsaw_time = self.monitor._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            
            logger.error(f"{time_str} ‚ùå Cloud Scheduler: B≈ÇƒÖd nocnego wybudzenia: {e}")
            
            self.send_response(500)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            response = {
                'status': 'midnight_wake_failed',
                'error': str(e),
                'timestamp': warsaw_time.isoformat(),
                'timezone': 'Europe/Warsaw',
                'trigger': 'cloud_scheduler'
            }
            
            self.wfile.write(json.dumps(response).encode())
    
    def log_message(self, format, *args):
        """Wy≈ÇƒÖcz standardowe logowanie HTTP serwera"""
        pass

class MonitoringState(Enum):
    """Stany monitorowania pojazdu"""
    IDLE = "idle"
    WAITING_FOR_OFFLINE = "waiting_for_offline"
    VEHICLE_AWOKEN = "vehicle_awoken"

@dataclass
class VehicleMonitoringCase:
    """Reprezentuje aktywny przypadek monitorowania pojazdu"""
    case_id: str
    vehicle_vin: str
    start_time: datetime
    state: MonitoringState
    last_battery_level: Optional[int] = None
    last_check_time: Optional[datetime] = None
    
    def to_dict(self) -> Dict:
        """Konwertuje do s≈Çownika dla serializacji"""
        return {
            'case_id': self.case_id,
            'vehicle_vin': self.vehicle_vin,
            'start_time': self.start_time.isoformat(),
            'state': self.state.value,
            'last_battery_level': self.last_battery_level,
            'last_check_time': self.last_check_time.isoformat() if self.last_check_time else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'VehicleMonitoringCase':
        """Tworzy instancjƒô z s≈Çownika"""
        return cls(
            case_id=data['case_id'],
            vehicle_vin=data['vehicle_vin'],
            start_time=datetime.fromisoformat(data['start_time']),
            state=MonitoringState(data['state']),
            last_battery_level=data.get('last_battery_level'),
            last_check_time=datetime.fromisoformat(data['last_check_time']) if data.get('last_check_time') else None
        )

class CloudTeslaMonitor:
    """G≈Ç√≥wna klasa monitorowania Tesla w Google Cloud"""
    
    def __init__(self):
        """Inicjalizacja monitora"""
        load_dotenv()
        
        # Konfiguracja strefy czasowej - CZAS WARSZAWSKI
        self.timezone = pytz.timezone('Europe/Warsaw')
        logger.info(f"Monitor skonfigurowany dla strefy czasowej: {self.timezone}")
        
        # Konfiguracja Tesla z diagnostykƒÖ po≈ÇƒÖczenia
        logger.info("üîß Inicjalizacja TeslaController...")
        
        # Sprawd≈∫ konfiguracjƒô Smart Tesla HTTP Proxy
        self.smart_proxy_mode = os.getenv('TESLA_SMART_PROXY_MODE') == 'true'
        self.proxy_available = os.getenv('TESLA_PROXY_AVAILABLE') == 'true'
        proxy_host = os.getenv('TESLA_HTTP_PROXY_HOST')
        proxy_port = os.getenv('TESLA_HTTP_PROXY_PORT')
        
        if self.smart_proxy_mode:
            logger.info("üîß Smart Proxy Mode w≈ÇƒÖczony")
            if self.proxy_available:
                logger.info(f"‚úÖ Tesla HTTP Proxy dostƒôpny: {proxy_host}:{proxy_port}")
                logger.info("üîß Proxy uruchamiany on-demand dla komend")
            else:
                logger.warning("‚ö†Ô∏è Tesla HTTP Proxy niedostƒôpny - tylko monitoring")
        elif proxy_host and proxy_port:
            logger.info(f"üîó Tesla HTTP Proxy skonfigurowane: {proxy_host}:{proxy_port}")
        else:
            logger.warning("‚ö†Ô∏è Tesla HTTP Proxy NIE jest skonfigurowane - u≈ºywam bezpo≈õrednio Fleet API")
            logger.warning("‚ö†Ô∏è Usuwanie harmonogram√≥w mo≈ºe nie dzia≈Çaƒá bez Tesla HTTP Proxy")
        
        # Stan proxy
        self.proxy_process = None
        self.proxy_running = False
        
        self.tesla_controller = TeslaController()
        
        # NAPRAWKA: Test po≈ÇƒÖczenia z Tesla HTTP Proxy TYLKO je≈õli jest skonfigurowany i private key gotowy
        if proxy_host and proxy_port and not self.smart_proxy_mode:
            # Tylko dla non-smart proxy mode - test po≈ÇƒÖczenia podczas startup
            private_key_ready = os.getenv('TESLA_PRIVATE_KEY_READY', 'false').lower() == 'true'
            if private_key_ready or os.path.exists('private-key.pem'):
                self._test_tesla_proxy_connection(proxy_host, proxy_port)
            else:
                logger.warning("‚ö†Ô∏è Private key niegotowy - pomijam test Tesla HTTP Proxy")
        elif self.smart_proxy_mode:
            logger.info("üí° Smart Proxy Mode - proxy bƒôdzie testowany on-demand")
        
        # Konfiguracja Google Cloud
        self.project_id = os.getenv('GOOGLE_CLOUD_PROJECT')
        self.bucket_name = os.getenv('GOOGLE_CLOUD_STORAGE_BUCKET', 'tesla-monitor-data')
        
        # Inicjalizacja klient√≥w Google Cloud
        self.storage_client = storage.Client() if self.project_id else None
        self.firestore_client = firestore.Client() if self.project_id else None
        
        # Stan monitorowania
        self.active_cases: Dict[str, VehicleMonitoringCase] = {}
        self.is_running = False
        
        # ≈öledzenie poprzedniego stanu pojazdu dla logowania tylko zmian
        self.last_vehicle_state: Dict[str, Any] = {}
        
        # HTTP server dla health check
        self.http_server = None
        self.http_thread = None
        
        # ≈Åadowanie stanu z Cloud Storage
        self._load_monitoring_state()
        
        # NOWE: Cache dla harmonogram√≥w OFF PEAK CHARGE
        self.last_off_peak_schedules: Dict[str, Dict] = {}  # VIN -> harmonogram hash
        self.last_tesla_schedules_home: Dict[str, List[Dict]] = {}  # VIN -> lista harmonogram√≥w HOME
        
    def _load_monitoring_state(self):
        """≈Åaduje stan monitorowania z Cloud Storage"""
        try:
            if not self.storage_client:
                logger.info("Brak konfiguracji Google Cloud Storage - u≈ºywam lokalnego stanu")
                return
                
            bucket = self.storage_client.bucket(self.bucket_name)
            blob = bucket.blob('monitoring_state.json')
            
            if blob.exists():
                state_data = json.loads(blob.download_as_text())
                self.active_cases = {
                    case_id: VehicleMonitoringCase.from_dict(case_data)
                    for case_id, case_data in state_data.get('active_cases', {}).items()
                }
                logger.info(f"Za≈Çadowano stan monitorowania: {len(self.active_cases)} aktywnych przypadk√≥w")
            else:
                logger.info("Brak zapisanego stanu monitorowania - rozpoczynam z pustym stanem")
                
        except Exception as e:
            logger.error(f"B≈ÇƒÖd ≈Çadowania stanu monitorowania: {e}")
    
    def _save_monitoring_state(self):
        """Zapisuje stan monitorowania do Cloud Storage"""
        try:
            if not self.storage_client:
                logger.debug("Brak konfiguracji Google Cloud Storage - pomijam zapis stanu")
                return
                
            state_data = {
                'active_cases': {
                    case_id: case.to_dict()
                    for case_id, case in self.active_cases.items()
                },
                'last_update': self._get_warsaw_time().isoformat()
            }
            
            bucket = self.storage_client.bucket(self.bucket_name)
            blob = bucket.blob('monitoring_state.json')
            blob.upload_from_string(json.dumps(state_data, indent=2))
            
            logger.debug("Stan monitorowania zapisany do Cloud Storage")
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd zapisu stanu monitorowania: {e}")
    
    def _get_warsaw_time(self) -> datetime:
        """
        Zwraca aktualny czas w strefie czasowej warszawskiej
        
        Returns:
            datetime: Czas w strefie Europe/Warsaw
        """
        return datetime.now(self.timezone)
    
    def _call_off_peak_charge_api(self, battery_level: int, vehicle_vin: str) -> Optional[Dict[str, Any]]:
        """
        Wywo≈Çuje OFF PEAK CHARGE API do obliczenia optymalnego harmonogramu ≈Çadowania
        
        Args:
            battery_level: Aktualny poziom baterii (%)
            vehicle_vin: VIN pojazdu
            
        Returns:
            Dict z odpowiedziƒÖ API lub fallback w przypadku b≈Çƒôdu
        """
        
        def _create_fallback_response(reason: str) -> Dict[str, Any]:
            """
            Tworzy fallback odpowied≈∫ z harmonogramem 13:00-15:00
            """
            logger.warning(f"‚ö†Ô∏è Tworzƒô fallback harmonogram (pow√≥d: {reason})")
            
            # Sta≈Çy harmonogram 13:00-15:00
            start_minutes = 13 * 60  # 13:00 = 780 minut
            end_minutes = 15 * 60    # 15:00 = 900 minut
            
            return {
                "success": True,
                "data": {
                    "summary": {
                        "scheduledSlots": 1,
                        "totalEnergy": 22,  # Oko≈Ço 11kW * 2h
                        "totalCost": 0,
                        "averagePrice": 0
                    },
                    "chargingSchedule": [{
                        "start_time": "13:00",
                        "end_time": "15:00",
                        "charge_amount": 22,
                        "cost": 0
                    }]
                }
            }

        try:
            # Konfiguracja API - pobierz z Google Cloud Secrets
            if not self.project_id:
                logger.warning("‚ö†Ô∏è Brak konfiguracji Google Cloud Project - nie mo≈ºna pobraƒá sekret√≥w OFF PEAK CHARGE API")
                return _create_fallback_response("brak konfiguracji Google Cloud")
            
            # Pobierz URL API z sekretu (z fallback'iem na domy≈õlnƒÖ warto≈õƒá)
            api_url = get_secret('OFF_PEAK_CHARGE_API_URL', self.project_id)
            if not api_url:
                api_url = 'http://localhost:3000/api/external-calculate'
                logger.info(f"‚ö†Ô∏è U≈ºywam domy≈õlnego URL OFF PEAK CHARGE API: {api_url}")
            
            # Pobierz klucz API z sekretu
            api_key = get_secret('OFF_PEAK_CHARGE_API_KEY', self.project_id)
            if not api_key:
                logger.warning("‚ö†Ô∏è Brak sekretu 'OFF_PEAK_CHARGE_API_KEY' w Google Cloud")
                return _create_fallback_response("brak klucza API")
            
            # Przygotuj dane ≈ºƒÖdania zgodnie z dokumentacjƒÖ
            request_data = {
                "batteryLevel": battery_level,
                "batteryCapacity": 75,
                "consumption": 18,
                "dailyMileage": 50,
                "chargeLimits": {
                    "optimalUpper": 0.8,
                    "optimalLower": 0.5,
                    "emergency": 0.2,
                    "chargingRate": 11
                }
            }
            
            # Przygotuj headers
            headers = {
                'Content-Type': 'application/json',
                'X-API-Key': api_key
            }
            
            # Loguj ≈ºƒÖdanie
            warsaw_time = self._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            logger.info(f"{time_str} üîÑ Wywo≈Çujƒô OFF PEAK CHARGE API")
            logger.info(f"URL: {api_url}")
            logger.info(f"Dane: {json.dumps(request_data, indent=2)}")
            
            # Wykonaj ≈ºƒÖdanie HTTP POST z timeout'em
            response = requests.post(
                api_url,
                json=request_data,
                headers=headers,
                timeout=30  # 30 sekund timeout
            )
            
            # Sprawd≈∫ status odpowiedzi
            if response.status_code == 200:
                response_data = response.json()
                
                # Loguj pomy≈õlnƒÖ odpowied≈∫
                logger.info(f"{time_str} ‚úÖ OFF PEAK CHARGE API - sukces")
                logger.info("=== ODPOWIED≈π OFF PEAK CHARGE API ===")
                logger.info(json.dumps(response_data, indent=2, ensure_ascii=False))
                logger.info("===================================")
                
                # Dodatkowe logowanie kluczowych informacji
                if response_data.get('success') and 'data' in response_data:
                    data = response_data['data']
                    summary = data.get('summary', {})
                    schedule_count = summary.get('scheduledSlots', 0)
                    total_energy = summary.get('totalEnergy', 0)
                    total_cost = summary.get('totalCost', 0)
                    avg_price = summary.get('averagePrice', 0)
                    
                    logger.info(f"{time_str} üìä Harmonogram: {schedule_count} sesji, {total_energy} kWh, {total_cost:.2f} z≈Ç (≈õrednia: {avg_price:.3f} z≈Ç/kWh)")
                    
                    # Loguj harmonogram ≈Çadowania
                    charging_schedule = data.get('chargingSchedule', [])
                    for i, slot in enumerate(charging_schedule, 1):
                        start_time = slot.get('start_time', '')
                        end_time = slot.get('end_time', '')
                        charge_amount = slot.get('charge_amount', 0)
                        cost = slot.get('cost', 0)
                        logger.info(f"{time_str} ‚ö° Sesja #{i}: {start_time} - {end_time}, {charge_amount} kWh, {cost:.2f} z≈Ç")
                
                return response_data
            else:
                logger.error(f"{time_str} ‚ùå B≈ÇƒÖd OFF PEAK CHARGE API - status {response.status_code}")
                return _create_fallback_response(f"b≈ÇƒÖd HTTP {response.status_code}")
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z OFF PEAK CHARGE API: {str(e)}")
            return _create_fallback_response(f"b≈ÇƒÖd po≈ÇƒÖczenia: {str(e)}")
        except Exception as e:
            logger.error(f"‚ùå Nieoczekiwany b≈ÇƒÖd podczas wywo≈Çywania OFF PEAK CHARGE API: {str(e)}")
            return _create_fallback_response(f"nieoczekiwany b≈ÇƒÖd: {str(e)}")
    
    def _log_event(self, message: str, battery_level: Optional[int] = None, 
                   vehicle_vin: Optional[str] = None, extra_data: Optional[Dict] = None):
        """
        Loguje zdarzenie do Google Cloud Logging z czasem warszawskim
        
        Args:
            message: Wiadomo≈õƒá do zalogowania
            battery_level: Poziom baterii (opcjonalnie)
            vehicle_vin: VIN pojazdu (opcjonalnie)
            extra_data: Dodatkowe dane (opcjonalnie)
        """
        warsaw_time = self._get_warsaw_time()
        log_data = {
            'timestamp': warsaw_time.isoformat(),
            'timestamp_utc': datetime.utcnow().isoformat(),
            'timezone': str(self.timezone),
            'event_message': message,  # Zmieniono z 'message' na 'event_message'
        }
        
        if battery_level is not None:
            log_data['battery_level'] = battery_level
            
        if vehicle_vin:
            log_data['vehicle_vin'] = vehicle_vin
            
        if extra_data:
            log_data.update(extra_data)
        
        # Logowanie do standardowego loggera (bez extra - to powodowa≈Ço konflikt)
        logger.info(f"Tesla Monitor: {message}")
        
        # Dodatkowe logowanie do Cloud Logging je≈õli dostƒôpne
        if self.firestore_client:
            try:
                collection = self.firestore_client.collection('tesla_monitor_logs')
                collection.add(log_data)
            except Exception as e:
                logger.error(f"B≈ÇƒÖd zapisu do Firestore: {e}")
    
    def _get_monitoring_schedule_interval(self) -> int:
        """
        Zwraca interwa≈Ç monitorowania w minutach na podstawie aktualnej godziny warszawskiej
        
        Returns:
            int: Interwa≈Ç w minutach (15 lub 60)
        """
        warsaw_time = self._get_warsaw_time()
        current_hour = warsaw_time.hour
        
        # CZAS WARSZAWSKI (Europe/Warsaw):
        # 07:00-23:00 (7-22): co 15 minut
        # 23:00-07:00 (23-6): co 60 minut
        if 7 <= current_hour <= 22:
            return 15
        else:
            return 60
    
    def reset_vehicle_state(self, vehicle_vin: str = None):
        """
        Resetuje zapamiƒôtany stan pojazdu aby wymusiƒá wykrycie jako nowy stan
        
        Args:
            vehicle_vin: VIN pojazdu do zresetowania (je≈õli None, resetuje wszystkie)
        """
        if vehicle_vin:
            if vehicle_vin in self.last_vehicle_state:
                del self.last_vehicle_state[vehicle_vin]
                logger.info(f"üîÑ Zresetowano stan pojazdu {vehicle_vin[-4:]}")
        else:
            self.last_vehicle_state.clear()
            logger.info("üîÑ Zresetowano stan wszystkich pojazd√≥w")
    
    def reset_all_monitoring_state(self):
        """
        Kompletny reset stanu monitorowania - wszystkie dane wracajƒÖ do stanu poczƒÖtkowego
        """
        warsaw_time = self._get_warsaw_time()
        time_str = warsaw_time.strftime("[%H:%M]")
        
        logger.info(f"{time_str} üîÑ === KOMPLETNY RESET STANU MONITOROWANIA ===")
        
        # 1. Reset stan√≥w pojazd√≥w
        vehicles_count = len(self.last_vehicle_state)
        self.last_vehicle_state.clear()
        logger.info(f"{time_str} ‚úÖ Zresetowano stany {vehicles_count} pojazd√≥w")
        
        # 2. Reset aktywnych przypadk√≥w
        cases_count = len(self.active_cases)
        self.active_cases.clear()
        logger.info(f"{time_str} ‚úÖ Zresetowano {cases_count} aktywnych przypadk√≥w monitorowania")
        
        # 3. Reset cache harmonogram√≥w OFF PEAK
        off_peak_count = len(self.last_off_peak_schedules)
        self.last_off_peak_schedules.clear()
        logger.info(f"{time_str} ‚úÖ Zresetowano cache {off_peak_count} harmonogram√≥w OFF PEAK")
        
        # 4. Reset cache harmonogram√≥w Tesla HOME
        tesla_home_count = len(self.last_tesla_schedules_home)
        self.last_tesla_schedules_home.clear()
        logger.info(f"{time_str} ‚úÖ Zresetowano cache {tesla_home_count} harmonogram√≥w Tesla HOME")
        
        # 5. Zapisz pusty stan do Cloud Storage
        try:
            self._save_monitoring_state()
            logger.info(f"{time_str} ‚úÖ Zapisano pusty stan do Cloud Storage")
        except Exception as e:
            logger.error(f"{time_str} ‚ùå B≈ÇƒÖd zapisu pustego stanu: {e}")
        
        # 6. Log zdarzenia resetu
        self._log_event(
            message="Complete monitoring state reset performed",
            extra_data={
                'action': 'complete_reset',
                'reset_vehicle_states': vehicles_count,
                'reset_active_cases': cases_count,
                'reset_off_peak_cache': off_peak_count,
                'reset_tesla_home_cache': tesla_home_count,
                'reset_timestamp': warsaw_time.isoformat(),
                'reset_reason': 'manual_testing_reset'
            }
        )
        
        logger.info(f"{time_str} üéâ RESET ZAKO≈ÉCZONY - aplikacja gotowa do testowania od poczƒÖtku")
        
        return {
            'reset_completed': True,
            'reset_timestamp': warsaw_time.isoformat(),
            'reset_counts': {
                'vehicle_states': vehicles_count,
                'active_cases': cases_count,
                'off_peak_cache': off_peak_count,
                'tesla_home_cache': tesla_home_count
            }
        }
    
    def reset_tesla_home_schedules(self, vehicle_vin: str = None) -> Dict[str, Any]:
        """
        Resetuje wszystkie harmonogramy HOME w Tesla - pobiera aktualne harmonogramy HOME i wszystkie usuwa
        
        Args:
            vehicle_vin: VIN pojazdu (opcjonalny, je≈õli nie podano u≈ºyje pierwszego dostƒôpnego)
            
        Returns:
            Dict z wynikami operacji
        """
        warsaw_time = self._get_warsaw_time()
        time_str = warsaw_time.strftime("[%H:%M]")
        
        logger.info(f"{time_str} üîÑ === RESET HARMONOGRAM√ìW HOME W TESLA ===")
        
        try:
            # 1. Sprawd≈∫ po≈ÇƒÖczenie z Tesla Controller
            if not self.tesla_controller.connect():
                error_msg = "Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z Tesla API"
                logger.error(f"{time_str} ‚ùå {error_msg}")
                return {
                    'success': False,
                    'error': error_msg,
                    'timestamp': warsaw_time.isoformat()
                }
            
            # 2. Wybierz pojazd
            if not vehicle_vin:
                # U≈ºyj pierwszego dostƒôpnego pojazdu
                if self.tesla_controller.vehicles:
                    vehicle_vin = self.tesla_controller.vehicles[0].get('vin')
                    logger.info(f"{time_str} üöó U≈ºyto pierwszego dostƒôpnego pojazdu: {vehicle_vin[-4:]}")
                else:
                    error_msg = "Brak dostƒôpnych pojazd√≥w"
                    logger.error(f"{time_str} ‚ùå {error_msg}")
                    return {
                        'success': False,
                        'error': error_msg,
                        'timestamp': warsaw_time.isoformat()
                    }
            
            # 3. Pobierz wszystkie harmonogramy HOME z Tesla
            logger.info(f"{time_str} üìã Pobieranie aktualnych harmonogram√≥w HOME z Tesla...")
            home_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
            
            if not home_schedules:
                logger.info(f"{time_str} ‚úÖ Brak harmonogram√≥w HOME do usuniƒôcia")
                return {
                    'success': True,
                    'message': 'Brak harmonogram√≥w HOME do usuniƒôcia',
                    'schedules_found': 0,
                    'schedules_removed': 0,
                    'timestamp': warsaw_time.isoformat()
                }
            
            logger.info(f"{time_str} üìã Znaleziono {len(home_schedules)} harmonogram√≥w HOME do usuniƒôcia")
            
            # 4. Wy≈õwietl szczeg√≥≈Çy harmonogram√≥w przed usuniƒôciem
            for i, schedule in enumerate(home_schedules):
                schedule_id = schedule.get('id', 'BRAK')
                start_time = schedule.get('start_time', 'N/A')
                end_time = schedule.get('end_time', 'N/A')
                enabled = schedule.get('enabled', False)
                lat = schedule.get('latitude', 0.0)
                lon = schedule.get('longitude', 0.0)
                
                logger.info(f"{time_str} üìã Harmonogram #{i+1}: ID={schedule_id}, {start_time}-{end_time}, enabled={enabled}, coords=({lat:.6f}, {lon:.6f})")
            
            # 5. Uruchom Tesla HTTP Proxy on-demand dla komend usuwania
            logger.info(f"{time_str} üöÄ Uruchamianie Tesla HTTP Proxy on-demand...")
            if not self._start_proxy_on_demand():
                logger.warning(f"{time_str} ‚ö†Ô∏è Tesla HTTP Proxy nie uruchomiony - pr√≥bujƒô usuwaƒá przez Fleet API")
            
            # 6. Usu≈Ñ wszystkie harmonogramy HOME jeden po drugim
            success_count = 0
            error_count = 0
            removed_schedule_ids = []
            
            for schedule in home_schedules:
                schedule_id = schedule.get('id')
                if schedule_id:
                    logger.info(f"{time_str} üóëÔ∏è Usuwanie harmonogramu HOME ID: {schedule_id}")
                    
                    try:
                        if self.tesla_controller.remove_charge_schedule(schedule_id):
                            success_count += 1
                            removed_schedule_ids.append(schedule_id)
                            logger.info(f"{time_str} ‚úÖ Usuniƒôto harmonogram ID: {schedule_id}")
                        else:
                            error_count += 1
                            logger.error(f"{time_str} ‚ùå Nie uda≈Ço siƒô usunƒÖƒá harmonogramu ID: {schedule_id}")
                    except Exception as remove_error:
                        error_count += 1
                        logger.error(f"{time_str} ‚ùå B≈ÇƒÖd usuwania harmonogramu ID {schedule_id}: {remove_error}")
                else:
                    error_count += 1
                    logger.error(f"{time_str} ‚ùå Harmonogram bez ID - pomijam")
            
            # 7. Zatrzymaj Tesla HTTP Proxy
            logger.info(f"{time_str} üõë Zatrzymywanie Tesla HTTP Proxy...")
            self._stop_proxy()
            
            # 8. Weryfikacja - sprawd≈∫ czy harmonogramy zosta≈Çy usuniƒôte
            logger.info(f"{time_str} üîç Weryfikacja usuniƒôcia harmonogram√≥w...")
            remaining_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
            
            # 9. Wyczy≈õƒá cache harmonogram√≥w Tesla HOME
            if vehicle_vin in self.last_tesla_schedules_home:
                del self.last_tesla_schedules_home[vehicle_vin]
                logger.info(f"{time_str} üßπ Wyczyszczono cache harmonogram√≥w Tesla HOME")
            
            # 10. Loguj wyniki
            result = {
                'success': success_count > 0 or len(home_schedules) == 0,
                'schedules_found': len(home_schedules),
                'schedules_removed': success_count,
                'schedules_failed': error_count,
                'removed_schedule_ids': removed_schedule_ids,
                'remaining_schedules': len(remaining_schedules),
                'timestamp': warsaw_time.isoformat(),
                'vehicle_vin': vehicle_vin[-4:] if vehicle_vin else 'Unknown'
            }
            
            # 11. Log zdarzenia
            self._log_event(
                message="Tesla HOME schedules reset completed",
                vehicle_vin=vehicle_vin,
                extra_data={
                    'action': 'reset_tesla_home_schedules',
                    'schedules_found': len(home_schedules),
                    'schedules_removed': success_count,
                    'schedules_failed': error_count,
                    'remaining_schedules': len(remaining_schedules),
                    'removed_ids': removed_schedule_ids
                }
            )
            
            if success_count == len(home_schedules):
                logger.info(f"{time_str} üéâ RESET HARMONOGRAM√ìW ZAKO≈ÉCZONY POMY≈öLNIE - usuniƒôto {success_count}/{len(home_schedules)} harmonogram√≥w")
            elif success_count > 0:
                logger.warning(f"{time_str} ‚ö†Ô∏è RESET CZƒò≈öCIOWO POMY≈öLNY - usuniƒôto {success_count}/{len(home_schedules)} harmonogram√≥w")
            else:
                logger.error(f"{time_str} ‚ùå RESET NIEUDANY - nie usuniƒôto ≈ºadnego harmonogramu")
            
            return result
            
        except Exception as e:
            error_msg = f"B≈ÇƒÖd resetowania harmonogram√≥w HOME: {e}"
            logger.error(f"{time_str} ‚ùå {error_msg}")
            
            # Zatrzymaj proxy w przypadku b≈Çƒôdu
            try:
                self._stop_proxy()
            except:
                pass
            
            return {
                'success': False,
                'error': error_msg,
                'timestamp': warsaw_time.isoformat()
            }
    
    def _check_vehicle_status(self) -> Optional[Dict[str, Any]]:
        """
        Sprawdza status pojazdu
        
        Returns:
            Dict z statusem pojazdu lub None w przypadku b≈Çƒôdu
        """
        try:
            # Test po≈ÇƒÖczenia z Tesla API (bez szczeg√≥≈Çowych log√≥w)
            try:
                if not self.tesla_controller.connect():
                    logger.error("‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z Tesla API")
                    
                    # Sprawd≈∫ stan autoryzacji dla lepszej diagnostyki
                    if hasattr(self.tesla_controller, 'check_authorization'):
                        try:
                            self.tesla_controller.check_authorization()
                        except Exception as auth_check_error:
                            logger.error(f"üí• B≈ÇƒÖd sprawdzania autoryzacji: {auth_check_error}")
                    
                    return None
            except Exception as conn_error:
                logger.error(f"‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z Tesla API: {conn_error}")
                
                # Dodatkowe informacje diagnostyczne dla b≈Çƒôd√≥w autoryzacji
                if "401" in str(conn_error) or "unauthorized" in str(conn_error).lower():
                    logger.error("üö´ B≈ÇƒÖd autoryzacji - sprawd≈∫ tokeny Tesla API")
                    # NAPRAWKA: Rzuƒá wyjƒÖtek autoryzacji aby g≈Ç√≥wna pƒôtla mog≈Ça przej≈õƒá w tryb oczekiwania
                    raise TeslaAuthenticationError("Token wygas≈Ç lub nieprawid≈Çowy", 401)
                elif "403" in str(conn_error) or "forbidden" in str(conn_error).lower():
                    logger.error("üö´ Brak uprawnie≈Ñ - sprawd≈∫ scope'y aplikacji w Tesla Developer Portal")
                    raise TeslaAuthenticationError("Brak uprawnie≈Ñ", 403)
                
                return None
            
            # Pobieranie statusu pojazdu z timeout'em
            try:
                # NAPRAWKA: Dodaj timeout na poziomie aplikacji
                import signal
                import threading
                
                status_result = None
                status_error = None
                status_finished = threading.Event()
                
                def get_status_with_timeout():
                    nonlocal status_result, status_error
                    try:
                        status_result = self.tesla_controller.get_vehicle_status()
                    except Exception as e:
                        status_error = e
                    finally:
                        status_finished.set()
                
                # Uruchom w osobnym wƒÖtku z timeout'em
                status_thread = threading.Thread(target=get_status_with_timeout, daemon=True)
                status_thread.start()
                
                # Czekaj maksymalnie 90 sekund na odpowied≈∫ Tesla API
                if status_finished.wait(timeout=90):
                    if status_error:
                        raise status_error
                    status = status_result
                else:
                    logger.error("‚è∞ TIMEOUT pobierania statusu pojazdu (90s) - Tesla API nie odpowiada")
                    return None
                
                if not status:
                    logger.error("‚ùå Nie uda≈Ço siƒô pobraƒá statusu pojazdu - otrzymano None")
                    return None
            except Exception as status_error:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania statusu: {status_error}")
                
                # NAPRAWKA: Sprawd≈∫ czy to b≈ÇƒÖd autoryzacji
                if "401" in str(status_error) or "unauthorized" in str(status_error).lower():
                    logger.error("üö´ Token Tesla wygas≈Ç podczas pobierania statusu")
                    raise TeslaAuthenticationError("Token wygas≈Ç podczas operacji", 401)
                
                return None
            
            # Logowanie prostego statusu pojazdu
            _log_simple_status(status)
                
            return status
            
        except Exception as e:
            logger.error(f"‚ùå KRYTYCZNY b≈ÇƒÖd sprawdzania statusu pojazdu: {e}")
            return None
    
    def _handle_condition_a(self, status: Dict[str, Any]):
        """
        Obs≈Çuguje warunek A: ONLINE + is_charging_ready=true + HOME
        
        Args:
            status: Status pojazdu
        """
        battery_level = status.get('battery_level', 0)
        vehicle_vin = status.get('vin', 'Unknown')
        
        # Pobierz aktualny czas warszawski
        warsaw_time = self._get_warsaw_time()
        time_str = warsaw_time.strftime("[%H:%M]")
        
        # Sprawd≈∫ czy to jest zmiana stanu (loguj tylko zmiany)
        last_state = self.last_vehicle_state.get(vehicle_vin, {})
        was_ready = last_state.get('is_charging_ready', False)
        was_home = last_state.get('location_status') == 'HOME'
        was_online = last_state.get('online', False)
        

        
        # Loguj tylko je≈õli to pierwsza detekcja tego stanu
        if not (was_ready and was_home and was_online):
            self._log_event(
                message="Car ready for schedule",
                battery_level=battery_level,
                vehicle_vin=vehicle_vin,
                extra_data={
                    'condition': 'A',
                    'charging_ready': True,
                    'location': 'HOME',
                    'state_change': 'new_ready_state'
                }
            )
            # U≈ºyj prostego logowania statusu
            _log_simple_status(status, "gotowy do ≈Çadowania")
            
            # NOWA FUNKCJONALNO≈öƒÜ: Wywo≈Çaj OFF PEAK CHARGE API i zarzƒÖdzaj harmonogramami
            try:
                api_response = self._call_off_peak_charge_api(battery_level, vehicle_vin)
                if api_response and api_response.get('success'):
                    # Sprawd≈∫ czy harmonogram jest r√≥≈ºny od poprzedniego
                    if self._is_schedule_different(vehicle_vin, api_response):
                        logger.info(f"{time_str} üîÑ Harmonogram R√ì≈ªNY - rozpoczynam zarzƒÖdzanie harmonogramami Tesla")
                        
                        # ZarzƒÖdzaj harmonogramami Tesla
                        if self._manage_tesla_charging_schedules(api_response, vehicle_vin):
                            logger.info(f"{time_str} ‚úÖ Pomy≈õlnie zaktualizowano harmonogramy ≈Çadowania Tesla")
                            
                            # Zapisz informacje o pe≈Çnej operacji
                            self._log_event(
                                message="OFF PEAK CHARGE schedule applied to Tesla successfully",
                                battery_level=battery_level,
                                vehicle_vin=vehicle_vin,
                                extra_data={
                                    'condition': 'A_schedule_update',
                                    'api_success': True,
                                    'schedule_updated': True,
                                    'scheduled_slots': api_response.get('data', {}).get('summary', {}).get('scheduledSlots', 0),
                                    'total_energy': api_response.get('data', {}).get('summary', {}).get('totalEnergy', 0),
                                    'total_cost': api_response.get('data', {}).get('summary', {}).get('totalCost', 0)
                                }
                            )
                        else:
                            logger.error(f"{time_str} ‚ùå B≈ÇƒÖd aktualizacji harmonogram√≥w Tesla")
                            self._log_event(
                                message="Failed to apply OFF PEAK CHARGE schedule to Tesla",
                                battery_level=battery_level,
                                vehicle_vin=vehicle_vin,
                                extra_data={
                                    'condition': 'A_schedule_update_failed',
                                    'api_success': True,
                                    'schedule_updated': False,
                                    'error': 'Tesla schedule management failed'
                                }
                            )
                    else:
                        logger.info(f"{time_str} üìã Harmonogram IDENTYCZNY - nie wykonujƒô zmian w Tesla")
                        
                        # Zapisz informacje o pominiƒôciu aktualizacji
                        self._log_event(
                            message="OFF PEAK CHARGE schedule unchanged - no Tesla update needed",
                            battery_level=battery_level,
                            vehicle_vin=vehicle_vin,
                            extra_data={
                                'condition': 'A_schedule_unchanged',
                                'api_success': True,
                                'schedule_updated': False,
                                'reason': 'identical_schedule'
                            }
                        )
                else:
                    logger.warning("‚ö†Ô∏è OFF PEAK CHARGE API - brak prawid≈Çowej odpowiedzi")
                    self._log_event(
                        message="OFF PEAK CHARGE API failed or returned invalid response",
                        battery_level=battery_level,
                        vehicle_vin=vehicle_vin,
                        extra_data={
                            'condition': 'A_api_failed',
                            'api_success': False,
                            'error': 'No valid API response'
                        }
                    )
            except Exception as api_error:
                logger.error(f"‚ùå B≈ÇƒÖd obs≈Çugi OFF PEAK CHARGE API: {api_error}")
                self._log_event(
                    message="OFF PEAK CHARGE API processing error",
                    battery_level=battery_level,
                    vehicle_vin=vehicle_vin,
                    extra_data={
                        'condition': 'A_api_error',
                        'api_success': False,
                        'error': str(api_error)
                    }
                )
        
        # NAPRAWKA: Zako≈Ñcz aktywny przypadek B je≈õli pojazd sta≈Ç siƒô gotowy
        if vehicle_vin in self.active_cases:
            case = self.active_cases[vehicle_vin]
            warsaw_tz = pytz.timezone('Europe/Warsaw')
            now = datetime.now(warsaw_tz)
            time_str = now.strftime("[%H:%M]")
            
            # Loguj zako≈Ñczenie przypadku B z powodu gotowo≈õci
            self._log_event(
                message="Monitoring case B terminated - car ready for charging",
                battery_level=battery_level,
                vehicle_vin=vehicle_vin,
                extra_data={
                    'condition': 'B_terminated_by_A',
                    'case_duration_minutes': (self._get_warsaw_time() - case.start_time).total_seconds() / 60,
                    'termination_reason': 'charging_ready_true'
                }
            )
            
            # Usu≈Ñ przypadek z aktywnych
            del self.active_cases[vehicle_vin]
            self._save_monitoring_state()
            logger.info(f"{time_str} ‚úÖ Zako≈Ñczono przypadek B - pojazd gotowy do ≈Çadowania")
    
    def _handle_condition_b(self, status: Dict[str, Any]):
        """
        Obs≈Çuguje warunek B: ONLINE + HOME + is_charging_ready=false (pierwszy raz)
        
        Args:
            status: Status pojazdu
        """
        vehicle_vin = status.get('vin', 'Unknown')
        battery_level = status.get('battery_level', 0)
        
        # Sprawd≈∫ czy to jest zmiana stanu (loguj tylko zmiany)
        last_state = self.last_vehicle_state.get(vehicle_vin, {})
        was_ready = last_state.get('is_charging_ready', True)  # Domy≈õlnie True, ≈ºeby wykryƒá zmianƒô na False
        was_home = last_state.get('location_status') == 'HOME'
        was_online = last_state.get('online', False)
        
        # Loguj tylko je≈õli to zmiana z gotowego na niegotowy
        if was_ready and not status.get('is_charging_ready', False):
            self._log_event(
                message="Car not ready for charging - monitoring started",
                battery_level=battery_level,
                vehicle_vin=vehicle_vin,
                extra_data={
                    'condition': 'B',
                    'charging_ready': False,
                    'location': 'HOME',
                    'state_change': 'ready_to_not_ready'
                }
            )
            # U≈ºyj prostego logowania statusu
            _log_simple_status(status, "niegotowy do ≈Çadowania")
        
        # Sprawd≈∫ czy ju≈º mamy aktywny przypadek dla tego pojazdu
        if vehicle_vin not in self.active_cases:
            # Utw√≥rz nowy przypadek monitorowania tylko je≈õli nie istnieje
            case_id = f"{vehicle_vin}_{int(time.time())}"
            new_case = VehicleMonitoringCase(
                case_id=case_id,
                vehicle_vin=vehicle_vin,
                start_time=self._get_warsaw_time(),
                state=MonitoringState.WAITING_FOR_OFFLINE,
                last_battery_level=status.get('battery_level', 0),
                last_check_time=self._get_warsaw_time()
            )
            
            self.active_cases[vehicle_vin] = new_case
            self._save_monitoring_state()
            
            warsaw_tz = pytz.timezone('Europe/Warsaw')
            now = datetime.now(warsaw_tz)
            time_str = now.strftime("[%H:%M]")
            logger.info(f"{time_str} üîÑ Rozpoczƒôto monitorowanie przypadku B")
        else:
            # Aktualizuj istniejƒÖcy przypadek
            case = self.active_cases[vehicle_vin]
            case.last_check_time = self._get_warsaw_time()
            case.last_battery_level = battery_level
    
    def _process_active_cases(self, current_status: Optional[Dict[str, Any]]):
        """
        Przetwarza aktywne przypadki monitorowania
        
        Args:
            current_status: Aktualny status pojazdu
        """
        if not current_status:
            return
        
        vehicle_vin = current_status.get('vin')
        if not vehicle_vin or vehicle_vin not in self.active_cases:
            return
        
        case = self.active_cases[vehicle_vin]
        is_online = current_status.get('online', False)
        
        if case.state == MonitoringState.WAITING_FOR_OFFLINE:
            if not is_online:
                # Pojazd przeszed≈Ç w stan OFFLINE - wykonaj akcje
                battery_level = case.last_battery_level or 0
                
                # Log: "Car ready for checking status"
                self._log_event(
                    message="Car ready for checking status",
                    battery_level=battery_level,
                    vehicle_vin=vehicle_vin,
                    extra_data={
                        'condition': 'B_offline',
                        'case_duration_minutes': (self._get_warsaw_time() - case.start_time).total_seconds() / 60
                    }
                )
                
                # Wybud≈∫ pojazd
                warsaw_tz = pytz.timezone('Europe/Warsaw')
                now = datetime.now(warsaw_tz)
                time_str = now.strftime("[%H:%M]")
                logger.info(f"{time_str} üîÑ Budzenie pojazdu {vehicle_vin[-4:]}")
                wake_success = self.tesla_controller.wake_up_vehicle(use_proxy=False)  # Przypadek B - bez proxy
                
                # Log: "Car was awaken"
                self._log_event(
                    message="Car was awaken",
                    vehicle_vin=vehicle_vin,
                    extra_data={
                        'condition': 'B_wake',
                        'wake_success': wake_success
                    }
                )
                
                # Sprawd≈∫ status po wybudzeniu
                if wake_success:
                    time.sleep(3)  # Kr√≥tka pauza po wybudzeniu
                    new_status = self._check_vehicle_status()
                    if new_status:
                        # U≈ºyj prostego logowania statusu po wybudzeniu
                        _log_simple_status(new_status, "po wybudzeniu")
                        
                        # NAPRAWKA: Sprawd≈∫ czy po wybudzeniu pojazd spe≈Çnia warunek A
                        is_online_after_wake = new_status.get('online', False)
                        is_charging_ready_after_wake = new_status.get('is_charging_ready', False)
                        location_after_wake = new_status.get('location_status', 'UNKNOWN')
                        
                        if is_online_after_wake and is_charging_ready_after_wake and location_after_wake == 'HOME':
                            logger.info(f"{time_str} ‚úÖ Po wybudzeniu: pojazd spe≈Çnia warunek A - wywo≈Çujƒô OFF PEAK CHARGE API")
                            try:
                                self._handle_condition_a(new_status)
                            except Exception as api_ex:
                                logger.error(f"‚ùå B≈ÇƒÖd wywo≈Çania warunku A po wybudzeniu: {api_ex}")
                
                # Zako≈Ñcz przypadek
                del self.active_cases[vehicle_vin]
                self._save_monitoring_state()
                logger.info(f"{time_str} ‚úÖ Zako≈Ñczono monitorowanie przypadku B")
            else:
                # Pojazd nadal ONLINE - aktualizuj timestamp
                case.last_check_time = self._get_warsaw_time()
                case.last_battery_level = current_status.get('battery_level', case.last_battery_level)
    
    def run_monitoring_cycle(self):
        """Wykonuje pojedynczy cykl monitorowania"""
        cycle_id = int(time.time())
        try:
            # NAPRAWKA: Je≈õli Smart Proxy Mode i komponenty gotowe, przygotuj proxy na poczƒÖtku cyklu
            if self.smart_proxy_mode and self.proxy_available:
                private_key_ready = os.getenv('TESLA_PRIVATE_KEY_READY', 'false').lower() == 'true'
                if private_key_ready and not self.proxy_running:
                    warsaw_time = self._get_warsaw_time()
                    time_str = warsaw_time.strftime("[%H:%M]")
                    logger.info(f"{time_str} üöÄ Przygotowywanie Tesla HTTP Proxy dla cyklu monitorowania...")
                    
                    # Pr√≥buj uruchomiƒá proxy
                    try:
                        proxy_started = self._start_proxy_on_demand()
                        if proxy_started:
                            logger.info(f"{time_str} ‚úÖ Tesla HTTP Proxy gotowy dla cyklu")
                        else:
                            logger.warning(f"{time_str} ‚ö†Ô∏è Tesla HTTP Proxy nie uruchomiony - cykl bƒôdzie ograniczony")
                    except Exception as proxy_ex:
                        logger.warning(f"{time_str} ‚ö†Ô∏è B≈ÇƒÖd uruchamiania proxy: {proxy_ex}")
            
            # Pobierz status pojazdu (bez szczeg√≥≈Çowych log√≥w cyklu)
            try:
                status = self._check_vehicle_status()
                if not status:
                    logger.warning(f"‚ö†Ô∏è Nie uda≈Ço siƒô pobraƒá statusu pojazdu")
                    return
            except TeslaAuthenticationError as auth_ex:
                logger.error(f"üö´ B≈ÇƒÖd autoryzacji Tesla: {auth_ex}")
                logger.error(f"‚ö†Ô∏è Mo≈ºliwe wyga≈õniƒôcie token√≥w - nale≈ºy ponownie autoryzowaƒá aplikacjƒô")
                # Nie przerywaj aplikacji - po prostu pomi≈Ñ ten cykl
                return
            except Exception as status_ex:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania statusu: {status_ex}")
                return
            
            is_online = status.get('online', False)
            is_charging_ready = status.get('is_charging_ready', False)
            location_status = status.get('location_status', 'UNKNOWN')
            
            # NOWA LOGIKA: Je≈õli Worker zosta≈Ç wywo≈Çany, a pojazd jest offline ‚Üí wybud≈∫ pojazd
            if not is_online:
                warsaw_time = self._get_warsaw_time()
                time_str = warsaw_time.strftime("[%H:%M]")
                vehicle_vin = status.get('vin', 'unknown')
                
                logger.info(f"üîÑ [WORKER] Pojazd {vehicle_vin[-4:]} jest offline - wybudzam przed cyklem")
                logger.info(f"{time_str} üö® WORKER: Pojazd offline wymaga wybudzenia")
                
                try:
                    # Sprawd≈∫ czy pojazd zosta≈Ç wybrany
                    if not self.tesla_controller.current_vehicle:
                        logger.info(f"{time_str} üîó ≈ÅƒÖczenie z Tesla API dla wybudzenia...")
                        tesla_connected = self.tesla_controller.connect()
                        if not tesla_connected:
                            logger.error(f"{time_str} ‚ùå Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z Tesla API")
                            logger.warning(f"{time_str} ‚ö†Ô∏è Kontynuujƒô cykl bez wybudzenia pojazdu")
                        elif not self.tesla_controller.current_vehicle:
                            logger.error(f"{time_str} ‚ùå Nie wybrano ≈ºadnego pojazdu po po≈ÇƒÖczeniu")
                            logger.warning(f"{time_str} ‚ö†Ô∏è Kontynuujƒô cykl bez wybudzenia pojazdu")
                        else:
                            selected_vin = self.tesla_controller.current_vehicle.get('vin', 'unknown')
                            logger.info(f"{time_str} ‚úÖ Wybrany pojazd do wybudzenia: {selected_vin[-4:]}")
                    
                    # Wybud≈∫ pojazd (bez proxy - Fleet API)
                    if self.tesla_controller.current_vehicle:
                        selected_vin = self.tesla_controller.current_vehicle.get('vin', 'unknown')
                        logger.info(f"üîÑ [WORKER] Budzenie pojazdu {selected_vin[-4:]} przez Fleet API...")
                        wake_success = self.tesla_controller.wake_up_vehicle(use_proxy=False)
                        
                        if wake_success:
                            logger.info(f"‚úÖ [WORKER] Pojazd {selected_vin[-4:]} wybudzony pomy≈õlnie")
                            logger.info(f"{time_str} ‚è≥ Oczekiwanie 5 sekund na pe≈Çne wybudzenie pojazdu...")
                            time.sleep(5)  # Pauza po wybudzeniu
                            
                            # Pobierz nowy status po wybudzeniu
                            logger.info(f"{time_str} üîÑ Sprawdzanie statusu pojazdu po wybudzeniu...")
                            new_status = self._check_vehicle_status()
                            if new_status:
                                status = new_status  # U≈ºyj nowego statusu
                                is_online = status.get('online', False)
                                is_charging_ready = status.get('is_charging_ready', False)
                                location_status = status.get('location_status', 'UNKNOWN')
                                logger.info(f"{time_str} üìä Status po wybudzeniu: online={is_online}, charging_ready={is_charging_ready}, location={location_status}")
                            else:
                                logger.warning(f"{time_str} ‚ö†Ô∏è Nie uda≈Ço siƒô pobraƒá statusu po wybudzeniu")
                        else:
                            logger.error(f"‚ùå [WORKER] Nie uda≈Ço siƒô wybudziƒá pojazdu {selected_vin[-4:]}")
                            logger.warning(f"{time_str} ‚ö†Ô∏è Kontynuujƒô cykl mimo niepowodzenia wybudzenia")
                        
                except Exception as wake_ex:
                    logger.error(f"‚ùå [WORKER] B≈ÇƒÖd wybudzania pojazdu: {wake_ex}")
                    logger.warning(f"{time_str} ‚ö†Ô∏è Kontynuujƒô cykl mimo b≈Çƒôdu wybudzenia")
                
                logger.info(f"{time_str} üöÄ Kontynuujƒô cykl monitorowania po pr√≥bie wybudzenia...")
            
            # Przetw√≥rz aktywne przypadki (bez szczeg√≥≈Çowych log√≥w)
            try:
                self._process_active_cases(status)
            except Exception as cases_ex:
                logger.error(f"‚ùå B≈ÇƒÖd przetwarzania przypadk√≥w: {cases_ex}")
                # Kontynuuj mimo b≈Çƒôdu
            
            # Sprawd≈∫ warunki g≈Ç√≥wne (bez szczeg√≥≈Çowych log√≥w)
            if is_online and location_status == 'HOME':
                if is_charging_ready:
                    # Warunek A: ONLINE + is_charging_ready=true + HOME
                    try:
                        self._handle_condition_a(status)
                    except Exception as cond_a_ex:
                        logger.error(f"‚ùå B≈ÇƒÖd obs≈Çugi warunku A: {cond_a_ex}")
                else:
                    # Warunek B: ONLINE + HOME + is_charging_ready=false
                    try:
                        self._handle_condition_b(status)
                    except Exception as cond_b_ex:
                        logger.error(f"‚ùå B≈ÇƒÖd obs≈Çugi warunku B: {cond_b_ex}")
            else:
                # Inne przypadki - loguj tylko je≈õli zmieni≈Ç siƒô stan
                vehicle_vin = status.get('vin', 'Unknown')
                last_state = self.last_vehicle_state.get(vehicle_vin, {})
                last_online = last_state.get('online', False)
                last_location = last_state.get('location_status', 'UNKNOWN')
                last_ready = last_state.get('is_charging_ready', False)
                
                # Sprawd≈∫ r√≥≈ºne typy zmian stanu
                state_changed = False
                change_messages = []
                
                if last_online != is_online:
                    if is_online:
                        change_messages.append("pojazd ONLINE")
                    else:
                        change_messages.append("pojazd OFFLINE")
                    state_changed = True
                
                if last_location != location_status:
                    if location_status == 'HOME':
                        change_messages.append("przyjecha≈Ç do DOMU")
                    elif last_location == 'HOME' and location_status not in ['UNKNOWN', 'UNAVAILABLE']:
                        # Tylko je≈õli lokalizacja jest znana i r√≥≈ºna od HOME
                        change_messages.append("wyjecha≈Ç z DOMU")
                    elif last_location == 'HOME' and location_status in ['UNKNOWN', 'UNAVAILABLE']:
                        # Pojazd by≈Ç w domu, teraz lokalizacja nieznana
                        change_messages.append("lokalizacja NIEZNANA (pojazd mo≈ºe byƒá nadal w domu)")
                    else:
                        change_messages.append(f"lokalizacja: {location_status}")
                    state_changed = True
                
                if last_ready != is_charging_ready:
                    if is_charging_ready:
                        change_messages.append("GOTOWY do ≈Çadowania")
                    else:
                        change_messages.append("NIEGOTOWY do ≈Çadowania")
                    state_changed = True
                
                if state_changed:
                    # Loguj znaczƒÖce zmiany stanu z prostym formatem
                    change_description = ", ".join(change_messages)
                    warsaw_tz = pytz.timezone('Europe/Warsaw')
                    now = datetime.now(warsaw_tz)
                    time_str = now.strftime("[%H:%M]")
                    logger.info(f"{time_str} üìç ZMIANA: {change_description}")
                    
                    # Loguj do bucket tylko znaczƒÖce zmiany
                    if (last_location == 'HOME' and location_status not in ['HOME', 'UNKNOWN', 'UNAVAILABLE']):
                        # Pojazd rzeczywi≈õcie wyjecha≈Ç z domu (lokalizacja znana i r√≥≈ºna od HOME)
                        self._log_event(
                            message="Car left home",
                            battery_level=status.get('battery_level', 0),
                            vehicle_vin=vehicle_vin,
                            extra_data={
                                'condition': 'departure',
                                'new_location': location_status,
                                'state_change': 'left_home'
                            }
                        )
                        _log_simple_status(status, "wyjazd z domu")
                    elif (last_location == 'HOME' and location_status in ['UNKNOWN', 'UNAVAILABLE']):
                        # Pojazd by≈Ç w domu, teraz lokalizacja nieznana - nie loguj jako wyjazd
                        self._log_event(
                            message="Car location unknown - may still be at home",
                            battery_level=status.get('battery_level', 0),
                            vehicle_vin=vehicle_vin,
                            extra_data={
                                'condition': 'location_unknown',
                                'previous_location': 'HOME',
                                'new_location': location_status,
                                'state_change': 'home_to_unknown'
                            }
                        )
                        _log_simple_status(status, "lokalizacja nieznana")
                    elif (last_location != 'HOME' and location_status == 'HOME'):
                        # Pojazd przyjecha≈Ç do domu
                        self._log_event(
                            message="Car arrived home",
                            battery_level=status.get('battery_level', 0),
                            vehicle_vin=vehicle_vin,
                            extra_data={
                                'condition': 'arrival',
                                'charging_ready': is_charging_ready,
                                'state_change': 'arrived_home'
                            }
                        )
                        _log_simple_status(status, "przyjazd do domu")
            
            # Zapisz aktualny stan pojazdu dla por√≥wnania w nastƒôpnym cyklu
            vehicle_vin = status.get('vin', 'Unknown')
            self.last_vehicle_state[vehicle_vin] = {
                'online': is_online,
                'is_charging_ready': is_charging_ready,
                'location_status': location_status,
                'battery_level': status.get('battery_level', 0),
                'last_update': self._get_warsaw_time().isoformat()
            }
                
        except Exception as e:
            logger.error(f"‚ùå KRYTYCZNY b≈ÇƒÖd w cyklu monitorowania: {e}")
            # Nie przerywaj aplikacji - loguj i kontynuuj
    
    def run_midnight_wake_check(self):
        """Wykonuje jednorazowe wybudzenie pojazdu o godzinie 0:00 czasu warszawskiego i sprawdza stan"""
        try:
            warsaw_time = self._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            logger.info(f"{time_str} üåô Nocne wybudzenie pojazdu")
            
            # NAPRAWKA: Po≈ÇƒÖczenie z Tesla API przed nocnym wybudzeniem
            logger.info(f"{time_str} üîó ≈ÅƒÖczenie z Tesla API przed nocnym wybudzeniem...")
            tesla_connected = self.tesla_controller.connect()
            if not tesla_connected:
                logger.error(f"{time_str} ‚ùå Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z Tesla API")
                logger.error(f"{time_str} ‚ùå Nocne wybudzenie przerwane - brak po≈ÇƒÖczenia z Tesla")
                return
            
            # Sprawd≈∫ czy pojazd zosta≈Ç wybrany
            if not self.tesla_controller.current_vehicle:
                logger.error(f"{time_str} ‚ùå Nie wybrano ≈ºadnego pojazdu po po≈ÇƒÖczeniu")
                logger.error(f"{time_str} ‚ùå Nocne wybudzenie przerwane - brak wybranego pojazdu")
                return
                
            selected_vin = self.tesla_controller.current_vehicle.get('vin', 'unknown')
            logger.info(f"{time_str} ‚úÖ Wybrany pojazd do wybudzenia: {selected_vin[-4:]}")
            
            # SMART PROXY: Uruchom proxy on-demand dla komendy wake_up
            proxy_started = False
            if self.smart_proxy_mode and self.proxy_available:
                logger.info(f"{time_str} üöÄ Uruchamianie Tesla HTTP Proxy on-demand dla wake_up...")
                proxy_started = self._start_proxy_on_demand()
                if not proxy_started:
                    logger.warning(f"{time_str} ‚ö†Ô∏è Nie uda≈Ço siƒô uruchomiƒá Tesla HTTP Proxy - pr√≥bujƒô wake_up bez proxy")
                else:
                    logger.info(f"{time_str} ‚úÖ Tesla HTTP Proxy uruchomiony dla wake_up")
            
            try:
                # Wybud≈∫ pojazd (z proxy je≈õli dostƒôpny)
                logger.info(f"{time_str} üîÑ Budzenie pojazdu {selected_vin[-4:]} {'przez Tesla HTTP Proxy' if proxy_started else 'bezpo≈õrednio Fleet API'}")
                wake_success = self.tesla_controller.wake_up_vehicle(use_proxy=proxy_started)
                
                # Log wybudzenia
                self._log_event(
                    message="Midnight wake-up initiated",
                    extra_data={
                        'action': 'midnight_wake',
                        'wake_success': wake_success,
                        'proxy_used': proxy_started,
                        'scheduled_time': '00:00',
                        'scheduled_timezone': 'Europe/Warsaw'
                    }
                )
                
                if wake_success:
                    # Poczekaj chwilƒô na pe≈Çne wybudzenie
                    time.sleep(5)
                    
                    # Sprawd≈∫ status po wybudzeniu
                    status = self._check_vehicle_status()
                    if status:
                        # Log stanu po wybudzeniu
                        self._log_event(
                            message="Midnight status check completed",
                            battery_level=status.get('battery_level', 0),
                            vehicle_vin=status.get('vin', 'Unknown'),
                            extra_data={
                                'action': 'midnight_status_check',
                                'charging_ready': status.get('is_charging_ready', False),
                                'location': status.get('location_status', 'UNKNOWN'),
                                'online': status.get('online', False),
                                'proxy_used': proxy_started,
                                'scheduled_time': '00:00',
                                'scheduled_timezone': 'Europe/Warsaw'
                            }
                        )
                        
                        # U≈ºyj prostego logowania statusu
                        _log_simple_status(status, "nocne sprawdzenie")
                        
                        # NAPRAWKA: Sprawd≈∫ czy po nocnym wybudzeniu pojazd spe≈Çnia warunek A
                        is_online_midnight = status.get('online', False)
                        is_charging_ready_midnight = status.get('is_charging_ready', False)
                        location_midnight = status.get('location_status', 'UNKNOWN')
                        

                        
                        if is_online_midnight and is_charging_ready_midnight and location_midnight == 'HOME':
                            logger.info(f"{time_str} ‚úÖ Po nocnym wybudzeniu: pojazd spe≈Çnia warunek A - wywo≈Çujƒô OFF PEAK CHARGE API")
                            try:
                                self._handle_condition_a(status)
                            except Exception as api_ex:
                                logger.error(f"‚ùå B≈ÇƒÖd wywo≈Çania warunku A po nocnym wybudzeniu: {api_ex}")
                        else:
                            logger.info(f"{time_str} ‚ÑπÔ∏è Po nocnym wybudzeniu: pojazd nie spe≈Çnia warunku A (online={is_online_midnight}, ready={is_charging_ready_midnight}, location={location_midnight})")
                    else:
                        logger.warning(f"{time_str} ‚ö†Ô∏è Nie uda≈Ço siƒô pobraƒá statusu po nocnym wybudzeniu")
                else:
                    logger.warning(f"{time_str} ‚ö†Ô∏è Nie uda≈Ço siƒô wybudziƒá pojazdu (proxy_used={proxy_started})")
                    
            finally:
                # SMART PROXY: Zatrzymaj proxy po zako≈Ñczeniu komendy wake_up
                if proxy_started and self.proxy_running:
                    logger.info(f"{time_str} üõë Zatrzymywanie Tesla HTTP Proxy po wake_up...")
                    self._stop_proxy()
                
        except Exception as e:
            warsaw_time = self._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            logger.error(f"{time_str} ‚ùå B≈ÇƒÖd podczas nocnego wybudzenia: {e}")
            
            # Zatrzymaj proxy w przypadku b≈Çƒôdu
            if hasattr(self, 'proxy_running') and self.proxy_running:
                self._stop_proxy()
    
    def setup_schedule(self):
        """Konfiguruje harmonogram monitorowania"""
        # NAPRAWKA: Nie czy≈õƒá harmonogramu je≈õli ju≈º istnieje z tym samym interwa≈Çem
        current_interval = self._get_monitoring_schedule_interval()
        
        # Sprawd≈∫ czy harmonogram ju≈º istnieje z w≈Ça≈õciwym interwa≈Çem
        existing_jobs = schedule.jobs
        if existing_jobs:
            # Sprawd≈∫ czy mamy ju≈º zadanie z w≈Ça≈õciwym interwa≈Çem
            for job in existing_jobs:
                if hasattr(job, 'interval') and job.interval == current_interval * 60:  # schedule u≈ºywa sekund
                    warsaw_time = self._get_warsaw_time()
                    logger.debug(f"Harmonogram ju≈º istnieje z interwa≈Çem {current_interval} min (czas: {warsaw_time.strftime('%H:%M:%S')})")
                    return  # Nie zmieniaj istniejƒÖcego harmonogramu
        
        # Wyczy≈õƒá poprzednie zadania TYLKO je≈õli potrzebna zmiana
        schedule.clear()
        
        # Konfiguruj harmonogram na podstawie aktualnej godziny
        interval = current_interval
        
        warsaw_time = self._get_warsaw_time()
        
        if interval == 15:
            # Godziny dzienne: co 15 minut
            schedule.every(15).minutes.do(self.run_monitoring_cycle)
            logger.info(f"Harmonogram: sprawdzanie co 15 minut (godziny dzienne 07:00-23:00 czasu warszawskiego, aktualnie: {warsaw_time.strftime('%H:%M:%S')})")
        else:
            # Godziny nocne: co 60 minut
            schedule.every(60).minutes.do(self.run_monitoring_cycle)
            logger.info(f"Harmonogram: sprawdzanie co 60 minut (godziny nocne 23:00-07:00 czasu warszawskiego, aktualnie: {warsaw_time.strftime('%H:%M:%S')})")
        
        # Jednorazowe wybudzenie pojazdu o godzinie 0:00 czasu warszawskiego
        schedule.every().day.at("00:00", "Europe/Warsaw").do(self.run_midnight_wake_check)
        logger.info("Harmonogram: jednorazowe wybudzenie pojazdu o godzinie 00:00 czasu warszawskiego (Europe/Warsaw)")
        
        # NAPRAWKA: Sprawdzaj interwa≈Ç rzadziej - co 2 godziny zamiast co godzinƒô
        schedule.every(2).hours.do(self.setup_schedule)
    
    def _start_health_server(self):
        """Uruchamia HTTP server dla health check"""
        try:
            port = int(os.getenv('PORT', '8080'))
            
            def handler(*args, **kwargs):
                return HealthCheckHandler(self, *args, **kwargs)
            
            self.http_server = HTTPServer(('0.0.0.0', port), handler)
            self.http_thread = threading.Thread(target=self.http_server.serve_forever, daemon=True)
            self.http_thread.start()
            
            logger.info(f"Health check server uruchomiony na porcie {port}")
        except Exception as e:
            logger.error(f"B≈ÇƒÖd uruchamiania health check server: {e}")
    
    def start_monitoring(self):
        """Uruchamia monitorowanie w trybie scheduler lub continuous"""
        warsaw_time = self._get_warsaw_time()
        time_str = warsaw_time.strftime("[%H:%M]")
        
        # Sprawd≈∫ tryb dzia≈Çania
        continuous_mode = os.getenv('CONTINUOUS_MODE', 'false').lower() == 'true'
        
        if continuous_mode:
            logger.info(f"{time_str} üîÑ Uruchamianie Cloud Tesla Monitor w trybie CONTINUOUS")
            self._start_continuous_monitoring()
        else:
            logger.info(f"{time_str} üìÖ Uruchamianie Cloud Tesla Monitor w trybie SCHEDULER (optymalizacja koszt√≥w)")
            self._start_scheduler_monitoring()
    
    def _start_scheduler_monitoring(self):
        """Uruchamia monitorowanie w trybie scheduler (optymalizacja koszt√≥w)"""
        warsaw_time = self._get_warsaw_time()
        time_str = warsaw_time.strftime("[%H:%M]")
        
        logger.info(f"{time_str} üí∞ TRYB SCHEDULER: Cloud Run skaluje do zera miƒôdzy wywo≈Çaniami")
        logger.info(f"{time_str} üìÖ Harmonogram zarzƒÖdzany przez Cloud Scheduler")
        logger.info(f"{time_str} üîó Endpointy dostƒôpne:")
        logger.info(f"{time_str}   - GET/POST /run-cycle - cykl monitorowania")
        logger.info(f"{time_str}   - GET/POST /run-midnight-wake - nocne wybudzenie")
        logger.info(f"{time_str}   - GET /health - sprawdzenie stanu")
        logger.info(f"{time_str}   - GET /reset - reset stanu")
        logger.info(f"{time_str}   - GET /reset-tesla-schedules - reset harmonogram√≥w Tesla")
        
        # Uruchom tylko HTTP server
        self._start_health_server()
        
        # Test po≈ÇƒÖczenia z Tesla (bez uruchamiania harmonogramu)
        tesla_connected = self.tesla_controller.connect()
        if tesla_connected:
            logger.info(f"{time_str} ‚úÖ Tesla API po≈ÇƒÖczone - gotowe do obs≈Çugi wywo≈Ça≈Ñ")
        else:
            logger.warning(f"{time_str} ‚ö†Ô∏è Tesla API niedostƒôpne - aplikacja dzia≈Ça w trybie oczekiwania")
        
        self.is_running = True
        
        # Prosta pƒôtla utrzymujƒÖca aplikacjƒô przy ≈ºyciu
        try:
            logger.info(f"{time_str} üéØ Aplikacja gotowa do obs≈Çugi wywo≈Ça≈Ñ Cloud Scheduler")
            
            while self.is_running:
                # Minimalne utrzymanie przy ≈ºyciu - sprawdzaj co 5 minut
                time.sleep(300)
                
                # Heartbeat co godzinƒô
                current_time = self._get_warsaw_time()
                if current_time.minute == 0:  # Raz na godzinƒô
                    time_str = current_time.strftime("[%H:%M]")
                    logger.info(f"{time_str} üíì Scheduler mode: Aplikacja aktywna, oczekuje na Cloud Scheduler")
                
        except KeyboardInterrupt:
            logger.info("‚õî Otrzymano sygna≈Ç przerwania - zatrzymywanie monitora")
            self.stop_monitoring()
        except Exception as e:
            logger.error(f"üí• KRYTYCZNY B≈ÅƒÑD w trybie scheduler: {e}")
            self.stop_monitoring()
            raise
    
    def _start_continuous_monitoring(self):
        """Uruchamia monitorowanie w trybie continuous (poprzednia implementacja)"""
        warsaw_time = self._get_warsaw_time()
        time_str = warsaw_time.strftime("[%H:%M]")
        
        logger.info(f"{time_str} üîÑ TRYB CONTINUOUS: Aplikacja dzia≈Ça ciƒÖgle (wy≈ºsze koszty)")
        logger.info(f"{time_str} ‚ö†Ô∏è Uwaga: Ten tryb generuje sta≈Çe koszty Cloud Run")
        
        # Uruchom health check server
        self._start_health_server()
        
        # Pierwsza konfiguracja harmonogramu
        self.setup_schedule()
        
        # Test po≈ÇƒÖczenia z Tesla
        tesla_connected = self.tesla_controller.connect()
        if not tesla_connected:
            logger.error(f"{time_str} ‚ùå Nie uda≈Ço siƒô po≈ÇƒÖczyƒá z Tesla API")
            logger.info(f"{time_str} ‚ö†Ô∏è Aplikacja bƒôdzie dzia≈Çaƒá w trybie oczekiwania")
            # Nie ko≈Ñczymy aplikacji - niech dzia≈Ça jako serwer
        
        self.is_running = True
        if tesla_connected:
            logger.info(f"{time_str} ‚úÖ Monitoring uruchomiony z po≈ÇƒÖczeniem Tesla")
            # Wykonaj pierwszy cykl monitorowania tylko je≈õli Tesla jest po≈ÇƒÖczona
            self.run_monitoring_cycle()
        else:
            logger.info(f"{time_str} ‚ö†Ô∏è Monitoring uruchomiony w trybie oczekiwania")
        
        # G≈Ç√≥wna pƒôtla monitorowania
        loop_iteration = 0
        try:
            while self.is_running:
                loop_iteration += 1
                warsaw_time = self._get_warsaw_time()
                
                # Uproszczony heartbeat - tylko co 60 minut
                if loop_iteration % 60 == 0:  # Co 60 iteracji (60 minut)
                    time_str = warsaw_time.strftime("[%H:%M]")
                    logger.info(f"{time_str} üíì Monitor dzia≈Ça")
                
                # Sprawd≈∫ i wykonaj zaplanowane zadania (tylko je≈õli Tesla jest po≈ÇƒÖczona)
                if tesla_connected:
                    try:
                        # Wykonaj zadania z timeout'em przy u≈ºyciu threading
                        import threading
                        import signal
                        
                        schedule_finished = threading.Event()
                        schedule_error = None
                        
                        def run_schedule_with_timeout():
                            nonlocal schedule_error
                            try:
                                schedule.run_pending()
                            except Exception as e:
                                schedule_error = e
                            finally:
                                schedule_finished.set()
                        
                        # Uruchom schedule w osobnym wƒÖtku
                        schedule_thread = threading.Thread(target=run_schedule_with_timeout, daemon=True)
                        schedule_thread.start()
                        
                        # Czekaj maksymalnie 5 minut na zako≈Ñczenie zada≈Ñ
                        if schedule_finished.wait(timeout=300):  # 5 minut timeout
                            if schedule_error:
                                raise schedule_error
                        else:
                            time_str = warsaw_time.strftime("[%H:%M]")
                            logger.error(f"{time_str} ‚è∞ TIMEOUT harmonogramu - zadanie trwa ponad 5 minut!")
                            
                    except Exception as schedule_error:
                        time_str = warsaw_time.strftime("[%H:%M]")
                        logger.error(f"{time_str} ‚ùå B≈ÇƒÖd w harmonogramie: {schedule_error}")
                        
                        # NAPRAWKA: W przypadku b≈Çƒôdu, sprawd≈∫ czy to nie problem z tokenami Tesla
                        if "401" in str(schedule_error) or "unauthorized" in str(schedule_error).lower():
                            logger.error(f"{time_str} üö´ B≈ÇƒÖd autoryzacji Tesla - mo≈ºliwe wyga≈õniƒôcie token√≥w")
                            tesla_connected = False  # Przejd≈∫ w tryb oczekiwania
                        
                        # Nie przerywaj pƒôtli - loguj i kontynuuj
                else:
                    # W trybie oczekiwania - sprawd≈∫ co jaki≈õ czas czy mo≈ºna siƒô po≈ÇƒÖczyƒá
                    if loop_iteration % 60 == 0:  # Co godzinƒô pr√≥buj po≈ÇƒÖczyƒá siƒô z Tesla
                        time_str = warsaw_time.strftime("[%H:%M]")
                        logger.info(f"{time_str} üîÑ Pr√≥ba ponownego po≈ÇƒÖczenia z Tesla API...")
                        if self.tesla_controller.connect():
                            tesla_connected = True
                            logger.info(f"{time_str} ‚úÖ Pomy≈õlnie po≈ÇƒÖczono z Tesla API")
                            self.setup_schedule()  # Ustaw harmonogram
                        else:
                            logger.info(f"{time_str} ‚ùå Nadal brak po≈ÇƒÖczenia z Tesla API")
                
                time.sleep(60)  # Sprawdzaj co minutƒô czy sƒÖ zadania do wykonania
                
        except KeyboardInterrupt:
            logger.info("‚õî Otrzymano sygna≈Ç przerwania - zatrzymywanie monitora")
            self.stop_monitoring()
        except Exception as e:
            logger.error(f"üí• KRYTYCZNY B≈ÅƒÑD w pƒôtli monitorowania (iteracja #{loop_iteration}): {e}")
            logger.error(f"üí• Typ b≈Çƒôdu: {type(e).__name__}")
            import traceback
            logger.error(f"üí• Stack trace: {traceback.format_exc()}")
            self.stop_monitoring()
            raise  # Re-raise ≈ºeby Cloud Run widzia≈Ç crash
    
    def stop_monitoring(self):
        """Zatrzymuje monitorowanie"""
        import traceback
        warsaw_time = self._get_warsaw_time()
        logger.info(f"üõë === ZATRZYMYWANIE CLOUD TESLA MONITOR === (czas: {warsaw_time.strftime('%H:%M:%S')})")
        
        # Loguj stan przed zatrzymaniem
        try:
            import psutil
            process = psutil.Process()
            memory = process.memory_info()
            logger.info(f"üîç Stan przed zatrzymaniem: pamiƒôƒá={memory.rss / 1024 / 1024:.1f}MB, wƒÖtki={process.num_threads()}")
        except Exception as e:
            logger.warning(f"üîç Nie mo≈ºna pobraƒá informacji o procesie: {e}")
        
        # Loguj stack trace aby zobaczyƒá skƒÖd wywo≈Çano stop_monitoring
        logger.info(f"üîç Stop monitoring wywo≈Çane z:")
        for line in traceback.format_stack():
            logger.info(f"üîç   {line.strip()}")
        
        self.is_running = False
        logger.info("üî¥ is_running ustawione na False")
        
        # SMART PROXY: Zatrzymaj proxy je≈õli dzia≈Ça
        if hasattr(self, 'proxy_running') and self.proxy_running:
            logger.info("üõë Zatrzymywanie Tesla HTTP Proxy...")
            self._stop_proxy()
        
        # Zatrzymaj HTTP server
        if self.http_server:
            try:
                self.http_server.shutdown()
                logger.info("‚úÖ Health check server zatrzymany")
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd zatrzymywania health check server: {e}")
        
        # Zapisz stan przed zako≈Ñczeniem
        try:
            self._save_monitoring_state()
            logger.info("‚úÖ Stan monitorowania zapisany")
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd zapisywania stanu: {e}")
        
        logger.info("üèÅ === MONITORING ZATRZYMANY ===")
    
    def get_status(self) -> Dict[str, Any]:
        """
        Zwraca aktualny status monitora
        
        Returns:
            Dict z informacjami o stanie monitora
        """
        return {
            'is_running': self.is_running,
            'active_cases_count': len(self.active_cases),
            'active_cases': [case.to_dict() for case in self.active_cases.values()],
            'current_interval_minutes': self._get_monitoring_schedule_interval(),
            'last_vehicle_states': self.last_vehicle_state,
            'project_id': self.project_id,
            'bucket_name': self.bucket_name,
            'last_check': self._get_warsaw_time().isoformat(),
            'timezone': 'Europe/Warsaw',
            'monitoring_logic': 'continuous_with_state_change_detection'
        }

    def _generate_schedule_hash(self, schedule_data: Dict[str, Any]) -> str:
        """
        Generuje hash dla harmonogramu ≈Çadowania z API OFF PEAK CHARGE
        
        Args:
            schedule_data: Dane harmonogramu z API OFF PEAK CHARGE
            
        Returns:
            str: Hash MD5 harmonogramu
        """
        try:
            # WyciƒÖgnij tylko istotne dane do por√≥wnania (bez timestamp, requestId itp.)
            charging_schedule = schedule_data.get('data', {}).get('chargingSchedule', [])
            
            # Posortuj harmonogram wed≈Çug czasu rozpoczƒôcia dla konsystencji
            sorted_schedule = sorted(charging_schedule, key=lambda x: x.get('start_time', ''))
            
            # Utw√≥rz hash na podstawie dat i czas√≥w ≈Çadowania
            hash_data = []
            for slot in sorted_schedule:
                hash_data.append({
                    'start_time': slot.get('start_time'),
                    'end_time': slot.get('end_time'),
                    'charge_amount': slot.get('charge_amount')
                })
            
            # Konwertuj na string i oblicz hash
            hash_string = json.dumps(hash_data, sort_keys=True)
            return hashlib.md5(hash_string.encode()).hexdigest()
        except Exception as e:
            logger.error(f"B≈ÇƒÖd generowania hash harmonogramu: {e}")
            return ""
    
    def _is_schedule_different(self, vehicle_vin: str, new_schedule_data: Dict[str, Any]) -> bool:
        """
        Sprawdza czy nowy harmonogram r√≥≈ºni siƒô od poprzedniego
        
        Args:
            vehicle_vin: VIN pojazdu
            new_schedule_data: Nowe dane harmonogramu z API OFF PEAK CHARGE
            
        Returns:
            bool: True je≈õli harmonogram jest r√≥≈ºny lub to pierwsza pr√≥ba
        """
        new_hash = self._generate_schedule_hash(new_schedule_data)
        last_hash = self.last_off_peak_schedules.get(vehicle_vin, {}).get('hash', '')
        
        is_different = new_hash != last_hash
        
        if is_different:
            # Zapisz nowy hash
            self.last_off_peak_schedules[vehicle_vin] = {
                'hash': new_hash,
                'timestamp': datetime.now().isoformat(),
                'schedule_data': new_schedule_data
            }
            logger.info(f"üìã Harmonogram dla {vehicle_vin[-4:]}: {'R√ì≈ªNY' if last_hash else 'PIERWSZY'} (hash: {new_hash[:8]}...)")
        else:
            logger.info(f"üìã Harmonogram dla {vehicle_vin[-4:]}: IDENTYCZNY (hash: {new_hash[:8]}...)")
        
        return is_different
    
    def _convert_off_peak_to_tesla_schedules(self, off_peak_data: Dict[str, Any], vehicle_vin: str) -> List[ChargeSchedule]:
        """
        Konwertuje harmonogram z API OFF PEAK CHARGE do formatu Tesla ChargeSchedule
        
        Args:
            off_peak_data: Dane z API OFF PEAK CHARGE
            vehicle_vin: VIN pojazdu
            
        Returns:
            List[ChargeSchedule]: Lista harmonogram√≥w w formacie Tesla
        """
        schedules = []
        charging_schedule = off_peak_data.get('data', {}).get('chargingSchedule', [])
        
        # Sprawd≈∫ czy harmonogram jest pusty (na podstawie summary)
        summary = off_peak_data.get('data', {}).get('summary', {})
        scheduled_slots = summary.get('scheduledSlots', 0)
        total_energy = summary.get('totalEnergy', 0)
        
        # Loguj informacje o harmonogramie
        if scheduled_slots == 0 or total_energy == 0:
            logger.warning(f"‚ö†Ô∏è  OFF PEAK API zwr√≥ci≈Ço pusty harmonogram: {scheduled_slots} sesji, {total_energy} kWh")
        else:
            logger.info(f"üìä OFF PEAK harmonogram: {scheduled_slots} sesji, {total_energy} kWh")
        
        try:
            # Pobierz lokalizacjƒô HOME z kontrolera Tesla
            if self.tesla_controller.current_vehicle:
                home_lat = self.tesla_controller.default_latitude
                home_lon = self.tesla_controller.default_longitude
            else:
                # Fallback do domy≈õlnych warto≈õci
                home_lat = float(os.getenv('HOME_LATITUDE', '52.334215'))
                home_lon = float(os.getenv('HOME_LONGITUDE', '20.937516'))
            
            for i, slot in enumerate(charging_schedule):
                # Parsuj czasy z formatu ISO 8601
                start_time_str = slot.get('start_time', '')
                end_time_str = slot.get('end_time', '')
                
                if not start_time_str or not end_time_str:
                    continue
                
                try:
                    # Konwertuj na czas warszawski i wyciƒÖgnij minuty od p√≥≈Çnocy
                    start_dt = datetime.fromisoformat(start_time_str.replace('Z', '+00:00'))
                    end_dt = datetime.fromisoformat(end_time_str.replace('Z', '+00:00'))
                    
                    # Konwertuj na czas warszawski
                    warsaw_tz = pytz.timezone('Europe/Warsaw')
                    start_warsaw = start_dt.astimezone(warsaw_tz)
                    end_warsaw = end_dt.astimezone(warsaw_tz)
                    
                    # Oblicz minuty od p√≥≈Çnocy
                    start_minutes = start_warsaw.hour * 60 + start_warsaw.minute
                    end_minutes = end_warsaw.hour * 60 + end_warsaw.minute
                    
                    # NAPRAWKA: Obs≈Çuga przej≈õcia przez p√≥≈Çnoc (np. 23:00-00:00)
                    # Je≈õli end_minutes < start_minutes, oznacza to przej≈õcie przez p√≥≈Çnoc
                    if end_minutes < start_minutes:
                        # Sprawd≈∫ czy to rzeczywi≈õcie przej≈õcie przez p√≥≈Çnoc
                        if start_warsaw.day != end_warsaw.day or end_warsaw.hour < start_warsaw.hour:
                            # Dodaj 24h w minutach dla kolejnego dnia
                            end_minutes += 24 * 60
                            logger.info(f"üåô Wykryto przej≈õcie przez p√≥≈Çnoc: {start_warsaw.strftime('%H:%M')}-{end_warsaw.strftime('%H:%M')} "
                                      f"‚Üí {start_minutes}-{end_minutes} min")
                    
                    # Normalizuj end_time do zakresu 0-1439 minut dla Tesla API
                    normalized_end_minutes = end_minutes % (24 * 60)
                    
                    # Utw√≥rz harmonogram Tesla
                    schedule = ChargeSchedule(
                        enabled=True,
                        start_time=start_minutes,
                        end_time=normalized_end_minutes,
                        start_enabled=True,
                        end_enabled=True,
                        days_of_week="All",  # Wszystkie dni tygodnia
                        lat=home_lat,
                        lon=home_lon,
                        one_time=False
                    )
                    
                    schedules.append(schedule)
                    
                    # Loguj konwersjƒô z informacjƒÖ o normalizacji
                    if end_minutes != normalized_end_minutes:
                        logger.info(f"üìÖ Harmonogram #{i+1}: {start_warsaw.strftime('%H:%M')}-{end_warsaw.strftime('%H:%M')} "
                                  f"({start_minutes}-{end_minutes} min ‚Üí normalizacja: {normalized_end_minutes} min), "
                                  f"{slot.get('charge_amount', 0)} kWh")
                    else:
                        logger.info(f"üìÖ Harmonogram #{i+1}: {start_warsaw.strftime('%H:%M')}-{end_warsaw.strftime('%H:%M')} "
                                  f"({start_minutes}-{end_minutes} min), "
                                  f"{slot.get('charge_amount', 0)} kWh")
                
                except Exception as e:
                    logger.error(f"B≈ÇƒÖd parsowania slotu #{i+1}: {e}")
                    continue
            
            # FALLBACK: Je≈õli brak harmonogram√≥w z OFF PEAK API, utw√≥rz 1-minutowy slot 23:59-00:00
            # Wykryj pusty harmonogram na podstawie:
            # 1. Brak schedules po parsowaniu
            # 2. Brak slot√≥w w charging_schedule  
            # 3. 0 scheduledSlots lub 0 totalEnergy w summary
            is_empty_schedule = (
                not schedules or 
                not charging_schedule or 
                scheduled_slots == 0 or 
                total_energy == 0
            )
            
            if is_empty_schedule:
                logger.warning("‚ö†Ô∏è  API OFF PEAK CHARGE zwr√≥ci≈Ço pusty harmonogram - tworzƒô fallback slot")
                
                # Ustaw sta≈Çy harmonogram fallback: 23:59-00:00 (1 minuta ≈Çadowania)
                start_minutes = 23 * 60 + 59  # 23:59 = 1439 minut od p√≥≈Çnocy
                end_minutes = 24 * 60         # 00:00 nastƒôpnego dnia = 1440 minut
                
                # Utw√≥rz fallback harmonogram
                fallback_schedule = ChargeSchedule(
                    enabled=True,
                    start_time=start_minutes,
                    end_time=end_minutes,  # Tesla API obs≈Çuguje 1440 jako 00:00 nastƒôpnego dnia
                    start_enabled=True,
                    end_enabled=True,
                    days_of_week="All",  # Wszystkie dni tygodnia
                    lat=home_lat,
                    lon=home_lon,
                    one_time=False
                )
                
                schedules.append(fallback_schedule)
                
                logger.info(f"üîÑ FALLBACK: Utworzono harmonogram ≈Çadowania 23:59-00:00:")
                logger.info(f"   üìÖ Czas: 23:59-00:00 (1 minuta ≈Çadowania)")
                logger.info(f"   üìç Minuty: {start_minutes}-{end_minutes}")
                logger.info(f"   ‚è∞ Harmonogram fallback - minimalny slot przed p√≥≈ÇnocƒÖ")
            
            logger.info(f"‚úÖ Skonwertowano {len(schedules)} harmonogram√≥w z API OFF PEAK CHARGE")
            return schedules
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd konwersji harmonogram√≥w: {e}")
            return []
    
    def _resolve_schedule_overlaps(self, schedules: List[ChargeSchedule], vehicle_vin: str) -> List[ChargeSchedule]:
        """
        RozwiƒÖzuje nak≈ÇadajƒÖce siƒô harmonogramy ≈Çadowania zachowujƒÖc priorytety z API
        
        Logika:
        1. Wykryj czy sƒÖ jakiekolwiek nak≈Çadania (optymalizacja)
        2. Je≈õli brak nak≈Çada≈Ñ, zwr√≥ƒá oryginalnƒÖ listƒô
        3. Je≈õli sƒÖ nak≈Çadania, usu≈Ñ harmonogramy o ni≈ºszym priorytecie
        4. Kolejno≈õƒá z API = priorytet (pierwszy = najwa≈ºniejszy)
        
        Args:
            schedules: Lista harmonogram√≥w do sprawdzenia
            vehicle_vin: VIN pojazdu (do logowania)
            
        Returns:
            List[ChargeSchedule]: Lista harmonogram√≥w bez nak≈Çada≈Ñ
        """
        if not schedules:
            return schedules
        
        # KROK 1: Szybkie wykrycie czy sƒÖ jakiekolwiek nak≈Çadania
        has_overlaps = self._detect_any_overlaps(schedules)
        
        if not has_overlaps:
            logger.info(f"‚úÖ Brak nak≈Çada≈Ñ w {len(schedules)} harmonogramach - zwracam oryginalnƒÖ listƒô")
            return schedules
        
        logger.warning(f"‚ö†Ô∏è Wykryto nak≈Çadania w harmonogramach - rozwiƒÖzywanie konflikt√≥w...")
        
        # KROK 2: RozwiƒÖ≈º nak≈Çadania zachowujƒÖc priorytety
        resolved_schedules = []
        
        for i, current_schedule in enumerate(schedules):
            # Sprawd≈∫ czy current_schedule nak≈Çada siƒô z ju≈º zaakceptowanymi harmonogramami
            has_conflict = False
            
            for accepted_schedule in resolved_schedules:
                if self._schedules_overlap(current_schedule, accepted_schedule):
                    logger.info(f"üö´ Harmonogram #{i+1} ({self.tesla_controller.minutes_to_time(current_schedule.start_time)}-"
                              f"{self.tesla_controller.minutes_to_time(current_schedule.end_time)}) "
                              f"nak≈Çada siƒô z wy≈ºszym priorytetem - POMIJAM")
                    has_conflict = True
                    break
            
            if not has_conflict:
                resolved_schedules.append(current_schedule)
                logger.info(f"‚úÖ Harmonogram #{i+1} ({self.tesla_controller.minutes_to_time(current_schedule.start_time)}-"
                          f"{self.tesla_controller.minutes_to_time(current_schedule.end_time)}) "
                          f"zaakceptowany (priorytet #{len(resolved_schedules)})")
        
        logger.info(f"üîß RozwiƒÖzano nak≈Çadania: {len(schedules)} ‚Üí {len(resolved_schedules)} harmonogram√≥w")
        return resolved_schedules

    def _detect_any_overlaps(self, schedules: List[ChargeSchedule]) -> bool:
        """
        Szybkie sprawdzenie czy w li≈õcie harmonogram√≥w sƒÖ jakiekolwiek nak≈Çadania
        
        Args:
            schedules: Lista harmonogram√≥w do sprawdzenia
            
        Returns:
            bool: True je≈õli znaleziono przynajmniej jedno nak≈Çadanie
        """
        for i, schedule1 in enumerate(schedules):
            for j, schedule2 in enumerate(schedules[i+1:], start=i+1):
                if self._schedules_overlap(schedule1, schedule2):
                    return True
        return False

    def _schedules_overlap(self, schedule1: ChargeSchedule, schedule2: ChargeSchedule) -> bool:
        """
        Sprawdza czy dwa harmonogramy nak≈ÇadajƒÖ siƒô czasowo
        
        Args:
            schedule1: Pierwszy harmonogram
            schedule2: Drugi harmonogram
            
        Returns:
            bool: True je≈õli harmonogramy siƒô nak≈ÇadajƒÖ
        """
        # Obs≈Çuga przej≈õcia przez p√≥≈Çnoc (end_time mo≈ºe byƒá > 1440)
        start1 = schedule1.start_time
        end1 = schedule1.end_time if schedule1.end_time <= 1440 else schedule1.end_time - 1440
        
        start2 = schedule2.start_time  
        end2 = schedule2.end_time if schedule2.end_time <= 1440 else schedule2.end_time - 1440
        
        # Sprawd≈∫ nak≈Çadanie: harmonogramy nak≈ÇadajƒÖ siƒô je≈õli:
        # - start1 < end2 AND start2 < end1
        return start1 < end2 and start2 < end1
    
    def _get_home_schedules_from_tesla(self, vehicle_vin: str) -> List[Dict]:
        """
        Pobiera harmonogramy ≈Çadowania z lokalizacji HOME z pojazdu Tesla
        
        Args:
            vehicle_vin: VIN pojazdu
            
        Returns:
            List[Dict]: Lista harmonogram√≥w HOME z Tesla
        """
        try:
            # Upewnij siƒô ≈ºe Tesla Controller jest po≈ÇƒÖczony i ma wybrany pojazd
            if not self.tesla_controller.current_vehicle:
                # Spr√≥buj po≈ÇƒÖczyƒá siƒô i wybraƒá pierwszy pojazd
                if self.tesla_controller.connect():
                    self.tesla_controller.list_vehicles()
                    if self.tesla_controller.vehicles:
                        # Znajd≈∫ pojazd o danym VIN
                        for i, vehicle in enumerate(self.tesla_controller.vehicles):
                            if vehicle.get('vin') == vehicle_vin:
                                if self.tesla_controller.select_vehicle(i):
                                    break
                        else:
                            # Je≈õli nie znaleziono VIN, u≈ºyj pierwszego pojazdu
                            self.tesla_controller.select_vehicle(0)
                else:
                    logger.error("Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z Tesla API")
                    return []
            
            if not self.tesla_controller.current_vehicle:
                logger.error(f"Nie mo≈ºna znale≈∫ƒá pojazdu {vehicle_vin[-4:]}")
                return []
            
            # Pobierz wszystkie harmonogramy
            all_schedules = self.tesla_controller.get_charge_schedules()
            
            if not all_schedules:
                logger.info(f"üìç Brak harmonogram√≥w w Tesla dla {vehicle_vin[-4:]}")
                return []
            
            # DEBUG: Wyloguj strukturƒô pierwszego harmonogramu
            if all_schedules:
                first_schedule = all_schedules[0]
                logger.debug(f"üìã DEBUG: Struktura harmonogramu - dostƒôpne pola: {list(first_schedule.keys())}")
                logger.debug(f"üìã DEBUG: Przyk≈Çadowy harmonogram: {first_schedule}")
            
            # Filtruj harmonogramy HOME (w okolicy domowej lokalizacji)
            home_schedules = []
            home_lat = self.tesla_controller.default_latitude
            home_lon = self.tesla_controller.default_longitude
            home_radius = self.tesla_controller.home_radius
            
            for schedule in all_schedules:
                # NAPRAWKA: Tesla API u≈ºywa 'latitude' i 'longitude', nie 'lat' i 'lon'
                schedule_lat = schedule.get('latitude', 0.0)
                schedule_lon = schedule.get('longitude', 0.0)
                
                # Oblicz odleg≈Ço≈õƒá od domu (proste przybli≈ºenie)
                if schedule_lat != 0.0 and schedule_lon != 0.0:
                    lat_diff = abs(schedule_lat - home_lat)
                    lon_diff = abs(schedule_lon - home_lon)
                    distance = (lat_diff**2 + lon_diff**2)**0.5
                    
                    if distance <= home_radius:
                        home_schedules.append(schedule)
                        logger.debug(f"üìç Harmonogram HOME: ID={schedule.get('id')}, odleg≈Ço≈õƒá={distance:.4f}, wsp√≥≈Çrzƒôdne=({schedule_lat:.6f}, {schedule_lon:.6f})")
                    else:
                        logger.debug(f"üìç Harmonogram OUTSIDE: ID={schedule.get('id')}, odleg≈Ço≈õƒá={distance:.4f}, wsp√≥≈Çrzƒôdne=({schedule_lat:.6f}, {schedule_lon:.6f})")
                else:
                    # Brak wsp√≥≈Çrzƒôdnych - pomijamy taki harmonogram (powinien byƒá bardzo rzadki)
                    logger.warning(f"üìç Harmonogram bez wsp√≥≈Çrzƒôdnych: ID={schedule.get('id')} - pomijam")
            
            logger.info(f"üìç Znaleziono {len(home_schedules)} harmonogram√≥w HOME z {len(all_schedules)} ca≈Çkowitych")
            return home_schedules
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd pobierania harmonogram√≥w HOME: {e}")
            return []
    

    
    def _add_schedules_to_tesla(self, schedules: List[ChargeSchedule], vehicle_vin: str) -> bool:
        """
        Dodaje harmonogramy ≈Çadowania do pojazdu Tesla z op√≥≈∫nieniami i weryfikacjƒÖ
        
        Args:
            schedules: Lista harmonogram√≥w do dodania
            vehicle_vin: VIN pojazdu
            
        Returns:
            bool: True je≈õli dodano wszystkie harmonogramy pomy≈õlnie
        """
        if not schedules:
            logger.info(f"üìÖ Brak harmonogram√≥w do dodania dla {vehicle_vin[-4:]}")
            return True
        
        try:
            success_count = 0
            failed_schedules = []
            
            for i, schedule in enumerate(schedules):
                # NAPRAWKA: Dodaj op√≥≈∫nienie miƒôdzy harmonogramami (Tesla API mo≈ºe nie nadƒÖ≈ºaƒá)
                if i > 0:
                    logger.info(f"‚è≥ Op√≥≈∫nienie 3s miƒôdzy harmonogramami...")
                    time.sleep(3)
                
                start_time = self.tesla_controller.minutes_to_time(schedule.start_time) if schedule.start_time else "N/A"
                end_time = self.tesla_controller.minutes_to_time(schedule.end_time) if schedule.end_time else "N/A"
                
                logger.info(f"üîÑ Dodawanie harmonogramu #{i+1}: {start_time}-{end_time}")
                
                if self.tesla_controller.add_charge_schedule(schedule):
                    success_count += 1
                    logger.info(f"‚úÖ Dodano harmonogram #{i+1}: {start_time}-{end_time}")
                else:
                    failed_schedules.append(f"#{i+1}: {start_time}-{end_time}")
                    logger.error(f"‚ùå B≈ÇƒÖd dodawania harmonogramu #{i+1}: {start_time}-{end_time}")
            
            # NAPRAWKA: Dodaj weryfikacjƒô po dodaniu harmonogram√≥w
            if success_count > 0:
                logger.info(f"üîç Weryfikacja dodanych harmonogram√≥w...")
                time.sleep(2)  # Kr√≥tkie op√≥≈∫nienie przed weryfikacjƒÖ
                
                # Sprawd≈∫ ile harmonogram√≥w HOME jest rzeczywi≈õcie w Tesla
                verification_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
                verified_count = len(verification_schedules)
                
                logger.info(f"üìä Weryfikacja: dodano {success_count}, znaleziono {verified_count} harmonogram√≥w HOME")
                
                # Loguj szczeg√≥≈Çy znalezionych harmonogram√≥w
                for j, verified_schedule in enumerate(verification_schedules):
                    schedule_id = verified_schedule.get('id', 'BRAK')
                    start_time_min = verified_schedule.get('start_time', 'N/A')
                    end_time_min = verified_schedule.get('end_time', 'N/A')
                    enabled = verified_schedule.get('enabled', False)
                    
                    # Konwertuj minuty na czas dla lepszego wy≈õwietlenia
                    if isinstance(start_time_min, int):
                        start_time_display = self.tesla_controller.minutes_to_time(start_time_min)
                    else:
                        start_time_display = str(start_time_min)
                    
                    if isinstance(end_time_min, int):
                        end_time_display = self.tesla_controller.minutes_to_time(end_time_min)
                    else:
                        end_time_display = str(end_time_min)
                    
                    logger.info(f"üìã Harmonogram #{j+1} w Tesla: ID={schedule_id}, "
                              f"{start_time_display}-{end_time_display}, enabled={enabled}")
                
                # Ostrze≈ºenie je≈õli liczba nie zgadza siƒô
                if verified_count != success_count:
                    logger.warning(f"‚ö†Ô∏è NIEZGODNO≈öƒÜ: wys≈Çano {success_count} harmonogram√≥w, "
                                 f"ale znaleziono {verified_count} w Tesla")
                    logger.warning(f"‚ö†Ô∏è Mo≈ºliwe przyczyny: konflikt harmonogram√≥w, op√≥≈∫nienia API, nadpisywanie")
                else:
                    logger.info(f"‚úÖ Weryfikacja pomy≈õlna: wszystkie harmonogramy dodane poprawnie")
            
            # Loguj szczeg√≥≈Çowe wyniki
            logger.info(f"üìä Wynik dodawania harmonogram√≥w:")
            logger.info(f"   ‚úÖ Pomy≈õlnie: {success_count}/{len(schedules)}")
            logger.info(f"   ‚ùå Nieudane: {len(failed_schedules)}")
            
            if failed_schedules:
                logger.error(f"‚ùå Nieudane harmonogramy: {', '.join(failed_schedules)}")
            
            return success_count == len(schedules)
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd dodawania harmonogram√≥w do Tesla: {e}")
            return False
    
    def _manage_tesla_charging_schedules(self, off_peak_data: Dict[str, Any], vehicle_vin: str) -> bool:
        """
        ZarzƒÖdza harmonogramami ≈Çadowania Tesla na podstawie danych z API OFF PEAK CHARGE
        U≈ºywa Smart Proxy Mode - uruchamia proxy on-demand dla komend
        NOWA SEKWENCJA: pobiera obecne -> przygotowuje nowe -> wysy≈Ça nowe -> usuwa stare
        
        Args:
            off_peak_data: Dane z API OFF PEAK CHARGE
            vehicle_vin: VIN pojazdu
            
        Returns:
            bool: True je≈õli zarzƒÖdzanie harmonogramami powiod≈Ço siƒô
        """
        try:
            warsaw_time = self._get_warsaw_time()
            time_str = warsaw_time.strftime("[%H:%M]")
            
            logger.info(f"{time_str} üîß Rozpoczƒôto zarzƒÖdzanie harmonogramami Tesla dla {vehicle_vin[-4:]}")
            
            # NAPRAWKA: Dodaj szczeg√≥≈ÇowƒÖ diagnostykƒô Smart Proxy Mode
            logger.info(f"{time_str} üîç Diagnostyka Smart Proxy Mode:")
            logger.info(f"   smart_proxy_mode = {self.smart_proxy_mode}")
            logger.info(f"   proxy_available = {self.proxy_available}")
            logger.info(f"   proxy_running = {self.proxy_running}")
            
            # Sprawd≈∫ zmienne ≈õrodowiskowe
            logger.info(f"   TESLA_SMART_PROXY_MODE = {os.getenv('TESLA_SMART_PROXY_MODE')}")
            logger.info(f"   TESLA_PROXY_AVAILABLE = {os.getenv('TESLA_PROXY_AVAILABLE')}")
            logger.info(f"   TESLA_HTTP_PROXY_HOST = {os.getenv('TESLA_HTTP_PROXY_HOST')}")
            logger.info(f"   TESLA_HTTP_PROXY_PORT = {os.getenv('TESLA_HTTP_PROXY_PORT')}")
            
            # SMART PROXY: Uruchom proxy on-demand dla komend
            proxy_started = False
            # Szczeg√≥≈Çowa diagnostyka Smart Proxy Mode
            logger.info(f"{time_str} üîç Smart Proxy Mode diagnostyka:")
            logger.info(f"   smart_proxy_mode = {self.smart_proxy_mode}")
            logger.info(f"   proxy_available = {self.proxy_available}")
            logger.info(f"   TESLA_SMART_PROXY_MODE = {os.getenv('TESLA_SMART_PROXY_MODE')}")
            logger.info(f"   TESLA_PROXY_AVAILABLE = {os.getenv('TESLA_PROXY_AVAILABLE')}")
            logger.info(f"   TESLA_HTTP_PROXY_HOST = {os.getenv('TESLA_HTTP_PROXY_HOST')}")
            logger.info(f"   TESLA_HTTP_PROXY_PORT = {os.getenv('TESLA_HTTP_PROXY_PORT')}")
            
            if self.smart_proxy_mode and self.proxy_available:
                logger.info(f"{time_str} üöÄ Uruchamianie Tesla HTTP Proxy on-demand...")
                proxy_started = self._start_proxy_on_demand()
                if not proxy_started:
                    logger.error(f"{time_str} ‚ùå Nie uda≈Ço siƒô uruchomiƒá Tesla HTTP Proxy")
                    logger.warning(f"{time_str} ‚ö†Ô∏è Pr√≥ba zarzƒÖdzania harmonogramami bez proxy (mo≈ºe nie dzia≈Çaƒá)")
                else:
                    logger.info(f"{time_str} ‚úÖ Tesla HTTP Proxy uruchomiony pomy≈õlnie")
                    
                    # NAPRAWKA: Upewnij siƒô ≈ºe TeslaController u≈ºywa proxy
                    if hasattr(self.tesla_controller, 'fleet_api'):
                        # Sprawd≈∫ konfiguracjƒô proxy w TeslaController
                        proxy_host = os.getenv('TESLA_HTTP_PROXY_HOST', 'localhost')
                        proxy_port = os.getenv('TESLA_HTTP_PROXY_PORT', '4443')
                        expected_proxy_url = f"https://{proxy_host}:{proxy_port}"
                        
                        current_proxy_url = getattr(self.tesla_controller.fleet_api, 'proxy_url', None)
                        
                        if current_proxy_url:
                            logger.info(f"{time_str} ‚úÖ TeslaController ma skonfigurowany proxy: {current_proxy_url}")
                        else:
                            # Ustaw proxy_url w fleet_api (to powinno byƒá zrobione przez konstruktor)
                            if hasattr(self.tesla_controller.fleet_api, 'proxy_url'):
                                self.tesla_controller.fleet_api.proxy_url = expected_proxy_url
                                logger.info(f"{time_str} üîó Skonfigurowano proxy w TeslaController: {expected_proxy_url}")
                            else:
                                logger.warning(f"{time_str} ‚ö†Ô∏è TeslaController nie obs≈Çuguje konfiguracji proxy")
            else:
                logger.warning(f"{time_str} ‚ö†Ô∏è Smart Proxy Mode wy≈ÇƒÖczony lub niedostƒôpny")
                if not self.smart_proxy_mode:
                    logger.warning(f"   - smart_proxy_mode = False (wy≈ÇƒÖczony)")
                if not self.proxy_available:
                    logger.warning(f"   - proxy_available = False (niedostƒôpny)")
            
            try:
                # 1. Pobierz obecne harmonogramy HOME z Tesla
                logger.info(f"{time_str} üìã Pobieranie obecnych harmonogram√≥w HOME...")
                current_home_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
                
                if current_home_schedules:
                    logger.info(f"{time_str} üìç Znaleziono {len(current_home_schedules)} starych harmonogram√≥w HOME")
                else:
                    logger.info(f"{time_str} üìç Brak starych harmonogram√≥w HOME")
                
                # 2. Konwertuj harmonogramy z API OFF PEAK CHARGE
                logger.info(f"{time_str} üîÑ Konwersja harmonogram√≥w z API OFF PEAK CHARGE...")
                new_schedules = self._convert_off_peak_to_tesla_schedules(off_peak_data, vehicle_vin)
                
                if not new_schedules:
                    logger.warning(f"{time_str} ‚ö†Ô∏è Brak harmonogram√≥w do dodania z API OFF PEAK CHARGE")
                    return True  # Techniczne powodzenie - po prostu nie ma harmonogram√≥w
                
                # 3. RozwiƒÖ≈º nak≈Çadania harmonogram√≥w (zachowaj kolejno≈õƒá priorytet√≥w z API)
                logger.info(f"{time_str} üîç Sprawdzanie nak≈Çada≈Ñ harmonogram√≥w...")
                resolved_schedules = self._resolve_schedule_overlaps(new_schedules, vehicle_vin)
                
                # NAPRAWKA: Szczeg√≥≈Çowe logowanie harmonogram√≥w przed dodaniem
                logger.info(f"{time_str} üìã Harmonogramy do dodania:")
                for k, schedule in enumerate(resolved_schedules):
                    start_time_display = self.tesla_controller.minutes_to_time(schedule.start_time) if schedule.start_time else "N/A"
                    end_time_display = self.tesla_controller.minutes_to_time(schedule.end_time) if schedule.end_time else "N/A"
                    logger.info(f"   #{k+1}: {start_time_display}-{end_time_display} "
                              f"(minuty: {schedule.start_time}-{schedule.end_time}), "
                              f"enabled={schedule.enabled}")
                
                # 4. Dodaj nowe harmonogramy do Tesla (wymaga proxy)
                logger.info(f"{time_str} ‚ûï Dodawanie {len(resolved_schedules)} nowych harmonogram√≥w...")
                
                if proxy_started:
                    # Poczekaj na pe≈Çne uruchomienie proxy
                    logger.info(f"{time_str} ‚è≥ Oczekiwanie na stabilizacjƒô proxy (3s)...")
                    time.sleep(3)
                    
                    addition_success = self._add_schedules_to_tesla(resolved_schedules, vehicle_vin)
                    if addition_success:
                        logger.info(f"{time_str} ‚úÖ Pomy≈õlnie dodano nowe harmonogramy Tesla")
                        
                        # NAPRAWKA: Dodaj szczeg√≥≈Çowe logowanie stanu po dodaniu
                        logger.info(f"{time_str} üîç Stan harmonogram√≥w HOME w Tesla po dodaniu:")
                        updated_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
                        if updated_schedules:
                            for f, updated_schedule in enumerate(updated_schedules):
                                schedule_id = updated_schedule.get('id', 'BRAK')
                                start_time_min = updated_schedule.get('start_time', 'N/A')
                                end_time_min = updated_schedule.get('end_time', 'N/A')
                                enabled = updated_schedule.get('enabled', False)
                                
                                if isinstance(start_time_min, int):
                                    start_display = self.tesla_controller.minutes_to_time(start_time_min)
                                else:
                                    start_display = str(start_time_min)
                                
                                if isinstance(end_time_min, int):
                                    end_display = self.tesla_controller.minutes_to_time(end_time_min)
                                else:
                                    end_display = str(end_time_min)
                                
                                logger.info(f"   Harmonogram #{f+1}: ID={schedule_id}, "
                                          f"{start_display}-{end_display}, enabled={enabled}")
                        
                        # 5. NOWA SEKWENCJA: Usu≈Ñ stare harmonogramy PO dodaniu nowych
                        if current_home_schedules:
                            logger.info(f"{time_str} üóëÔ∏è Usuwanie {len(current_home_schedules)} starych harmonogram√≥w HOME...")
                            removal_success = self._remove_old_schedules_from_tesla(current_home_schedules, vehicle_vin)
                            if not removal_success:
                                logger.warning(f"{time_str} ‚ö†Ô∏è Nie wszystkie stare harmonogramy zosta≈Çy usuniƒôte")
                                logger.info(f"{time_str} üí° Nowe harmonogramy zosta≈Çy dodane pomy≈õlnie")
                            else:
                                logger.info(f"{time_str} ‚úÖ Pomy≈õlnie usuniƒôto stare harmonogramy HOME")
                        else:
                            logger.info(f"{time_str} üìç Brak starych harmonogram√≥w HOME do usuniƒôcia")
                        
                        # NAPRAWKA: Dodaj szczeg√≥≈Çowe logowanie ko≈Ñcowego stanu
                        logger.info(f"{time_str} üîç Ko≈Ñcowy stan harmonogram√≥w HOME w Tesla:")
                        final_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
                        if final_schedules:
                            for f, final_schedule in enumerate(final_schedules):
                                schedule_id = final_schedule.get('id', 'BRAK')
                                start_time_min = final_schedule.get('start_time', 'N/A')
                                end_time_min = final_schedule.get('end_time', 'N/A')
                                enabled = final_schedule.get('enabled', False)
                                
                                if isinstance(start_time_min, int):
                                    start_display = self.tesla_controller.minutes_to_time(start_time_min)
                                else:
                                    start_display = str(start_time_min)
                                
                                if isinstance(end_time_min, int):
                                    end_display = self.tesla_controller.minutes_to_time(end_time_min)
                                else:
                                    end_display = str(end_time_min)
                                
                                logger.info(f"   Aktywny #{f+1}: ID={schedule_id}, "
                                          f"{start_display}-{end_display}, enabled={enabled}")
                        else:
                            logger.info(f"{time_str} üìç Brak harmonogram√≥w HOME w Tesla po operacji")
                        
                        # Zapisz informacje o operacji
                        operation_data = {
                            'operation': 'schedule_management_new_sequence',
                            'old_schedules_count': len(current_home_schedules),
                            'added_schedules': len(resolved_schedules),
                            'final_schedules': len(final_schedules) if final_schedules else 0,
                            'operation_success': True,
                            'proxy_used': True,
                            'sequence_version': 'v3.0_no_charge_commands'
                        }
                        
                        self._log_event(
                            message="Tesla charging schedules updated with new sequence (no charge start/stop commands)",
                            vehicle_vin=vehicle_vin,
                            extra_data=operation_data
                        )
                        
                        return True
                    else:
                        logger.error(f"{time_str} ‚ùå B≈ÇƒÖd dodawania nowych harmonogram√≥w")
                        
                        # NAPRAWKA: Loguj stan po nieudanym dodaniu
                        logger.error(f"{time_str} üîç Stan harmonogram√≥w HOME po nieudanym dodaniu:")
                        error_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
                        if error_schedules:
                            for e, error_schedule in enumerate(error_schedules):
                                schedule_id = error_schedule.get('id', 'BRAK')
                                start_time_min = error_schedule.get('start_time', 'N/A')
                                end_time_min = error_schedule.get('end_time', 'N/A')
                                enabled = error_schedule.get('enabled', False)
                                logger.error(f"   Pozosta≈Çy #{e+1}: ID={schedule_id}, "
                                           f"{start_time_min}-{end_time_min}, enabled={enabled}")
                        else:
                            logger.error(f"{time_str} ‚ùå Brak harmonogram√≥w HOME w Tesla po nieudanym dodaniu")
                        
                        return False
                else:
                    logger.error(f"{time_str} ‚ùå Nie mo≈ºna dodaƒá harmonogram√≥w - brak Tesla HTTP Proxy")
                    logger.error(f"{time_str} üí° Komendy add/remove_charge_schedule wymagajƒÖ Tesla HTTP Proxy")
                    logger.error(f"{time_str} üí° Fleet API nie obs≈Çuguje tych komend bez proxy")
                    
                    self._log_event(
                        message="Tesla charging schedules management failed - no proxy available",
                        vehicle_vin=vehicle_vin,
                        extra_data={
                            'operation': 'schedule_management_failed',
                            'error': 'no_proxy_available',
                            'operation_success': False,
                            'proxy_used': False,
                            'smart_proxy_mode': self.smart_proxy_mode,
                            'proxy_available': self.proxy_available
                        }
                    )
                    return False
                    
            finally:
                # SMART PROXY: Zatrzymaj proxy po zako≈Ñczeniu komend
                if proxy_started and self.proxy_running:
                    logger.info(f"{time_str} üõë Zatrzymywanie Tesla HTTP Proxy po zako≈Ñczeniu komend...")
                    self._stop_proxy()
                    
                    # NAPRAWKA: Przywr√≥ƒá TeslaController do u≈ºywania Fleet API
                    if hasattr(self.tesla_controller, 'fleet_api') and hasattr(self.tesla_controller.fleet_api, 'use_proxy'):
                        self.tesla_controller.fleet_api.use_proxy = False
                        logger.info(f"{time_str} üîô TeslaController przywr√≥cony do Fleet API")
                    
        except Exception as e:
            logger.error(f"B≈ÇƒÖd zarzƒÖdzania harmonogramami Tesla: {e}")
            logger.error(f"Typ b≈Çƒôdu: {type(e).__name__}")
            import traceback
            logger.error(f"Stack trace: {traceback.format_exc()}")
            
            self._log_event(
                message=f"Tesla charging schedules management error: {e}",
                vehicle_vin=vehicle_vin,
                extra_data={
                    'operation': 'schedule_management_error',
                    'error': str(e),
                    'error_type': type(e).__name__,
                    'operation_success': False
                }
            )
            return False

    def _disable_home_schedules_from_tesla(self, vehicle_vin: str) -> bool:
        """
        Wy≈ÇƒÖcza wszystkie harmonogramy ≈Çadowania z lokalizacji HOME z pojazdu Tesla
        (alternatywa dla usuwania, gdy Fleet API nie obs≈Çuguje remove_charge_schedule)
        
        Args:
            vehicle_vin: VIN pojazdu
            
        Returns:
            bool: True je≈õli wy≈ÇƒÖczono harmonogramy pomy≈õlnie
        """
        try:
            home_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
            
            if not home_schedules:
                logger.info(f"üìç Brak harmonogram√≥w HOME do wy≈ÇƒÖczenia dla {vehicle_vin[-4:]}")
                return True
            
            success_count = 0
            for schedule in home_schedules:
                schedule_id = schedule.get('id')
                if schedule_id and schedule.get('enabled', False):
                    # Wy≈ÇƒÖcz harmonogram modyfikujƒÖc go z enabled=False
                    try:
                        modified_schedule = ChargeSchedule(
                            id=schedule_id,
                            enabled=False,  # Wy≈ÇƒÖcz harmonogram
                            days_of_week=schedule.get('days_of_week', 'All'),
                            lat=schedule.get('latitude', self.tesla_controller.default_latitude),
                            lon=schedule.get('longitude', self.tesla_controller.default_longitude),
                            start_enabled=schedule.get('start_enabled', False),
                            end_enabled=schedule.get('end_enabled', False),
                            start_time=schedule.get('start_time'),
                            end_time=schedule.get('end_time'),
                            one_time=schedule.get('one_time', False)
                        )
                        
                        if self.tesla_controller.add_charge_schedule(modified_schedule):
                            success_count += 1
                            logger.info(f"üîï Wy≈ÇƒÖczono harmonogram HOME ID: {schedule_id}")
                        else:
                            logger.error(f"‚ùå B≈ÇƒÖd wy≈ÇƒÖczania harmonogramu HOME ID: {schedule_id}")
                    except Exception as modify_error:
                        logger.error(f"‚ùå B≈ÇƒÖd modyfikacji harmonogramu HOME ID {schedule_id}: {modify_error}")
                elif schedule_id and not schedule.get('enabled', True):
                    logger.info(f"‚ÑπÔ∏è Harmonogram HOME ID {schedule_id} ju≈º wy≈ÇƒÖczony")
                    success_count += 1
            
            logger.info(f"üîï Wy≈ÇƒÖczono {success_count}/{len(home_schedules)} harmonogram√≥w HOME")
            return success_count == len(home_schedules)
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd wy≈ÇƒÖczania harmonogram√≥w HOME: {e}")
            return False

    def _start_proxy_on_demand(self) -> bool:
        """
        Uruchamia Tesla HTTP Proxy on-demand
        
        Returns:
            bool: True je≈õli proxy zosta≈Ç uruchomiony pomy≈õlnie
        """
        if not self.smart_proxy_mode or not self.proxy_available:
            logger.warning("‚ö†Ô∏è Smart Proxy Mode wy≈ÇƒÖczony lub proxy niedostƒôpny")
            logger.warning(f"   smart_proxy_mode = {self.smart_proxy_mode}")
            logger.warning(f"   proxy_available = {self.proxy_available}")
            return False
        
        # NAPRAWKA: Sprawd≈∫ gotowo≈õƒá private key przed uruchomieniem proxy
        private_key_ready = os.getenv('TESLA_PRIVATE_KEY_READY', 'false').lower() == 'true'
        if not private_key_ready:
            logger.warning("‚ö†Ô∏è Private key nie jest gotowy - nie mo≈ºna uruchomiƒá Tesla HTTP Proxy")
            logger.warning("üí° Sprawd≈∫ czy startup_worker.sh poprawnie pobra≈Ç private key")
            return False
        
        # Sprawd≈∫ czy plik private key istnieje i nie jest pusty
        if not os.path.exists('private-key.pem'):
            logger.error("‚ùå Plik private-key.pem nie istnieje")
            return False
        
        try:
            key_size = os.path.getsize('private-key.pem')
            if key_size == 0:
                logger.error("‚ùå Plik private-key.pem jest pusty")
                return False
            logger.info(f"‚úÖ Private key zweryfikowany ({key_size} bajt√≥w)")
        except Exception as key_error:
            logger.error(f"‚ùå B≈ÇƒÖd sprawdzania private key: {key_error}")
            return False
        
        if self.proxy_running:
            logger.info("üîß Tesla HTTP Proxy ju≈º dzia≈Ça - sprawdzam po≈ÇƒÖczenie...")
            if self._test_proxy_connection():
                logger.info("‚úÖ Tesla HTTP Proxy jest aktywny i odpowiada")
                return True
            else:
                logger.warning("‚ö†Ô∏è Tesla HTTP Proxy proces dzia≈Ça ale nie odpowiada - restartujƒô...")
                self._stop_proxy()
        
        try:
            import subprocess
            import time
            
            proxy_host = os.getenv('TESLA_HTTP_PROXY_HOST', 'localhost')
            proxy_port = os.getenv('TESLA_HTTP_PROXY_PORT', '4443')
            
            logger.info(f"üöÄ Uruchamianie Tesla HTTP Proxy on-demand...")
            logger.info(f"   Host: {proxy_host}")
            logger.info(f"   Port: {proxy_port}")
            
            # Sprawd≈∫ czy port jest wolny
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            result = sock.connect_ex((proxy_host, int(proxy_port)))
            sock.close()
            
            if result == 0:
                logger.warning(f"‚ö†Ô∏è Port {proxy_port} jest ju≈º zajƒôty - sprawdzam czy to nasze proxy...")
                if self._test_proxy_connection():
                    logger.info("‚úÖ Znaleziono dzia≈ÇajƒÖce Tesla HTTP Proxy na porcie")
                    self.proxy_running = True
                    return True
                else:
                    logger.error(f"‚ùå Port {proxy_port} zajƒôty przez inny proces")
                    return False
            
            # Sprawd≈∫ czy private-key.pem istnieje
            if not os.path.exists('private-key.pem'):
                logger.error("‚ùå Brak pliku private-key.pem - proxy nie mo≈ºe byƒá uruchomiony")
                logger.error("üí° Sprawd≈∫ czy klucz zosta≈Ç pobrany z Secret Manager")
                return False
            
            # Sprawd≈∫ rozmiar klucza prywatnego
            try:
                key_size = os.path.getsize('private-key.pem')
                if key_size == 0:
                    logger.error("‚ùå Plik private-key.pem jest pusty")
                    return False
                logger.info(f"‚úÖ Klucz prywatny znaleziony ({key_size} bajt√≥w)")
            except Exception as key_error:
                logger.error(f"‚ùå B≈ÇƒÖd sprawdzania klucza prywatnego: {key_error}")
                return False
            
            # Generuj certyfikaty TLS je≈õli nie istniejƒÖ
            if not os.path.exists('tls-key.pem') or not os.path.exists('tls-cert.pem'):
                logger.info("üîê Generowanie certyfikat√≥w TLS...")
                try:
                    result = subprocess.run([
                        'openssl', 'req', '-x509', '-newkey', 'rsa:4096',
                        '-keyout', 'tls-key.pem', '-out', 'tls-cert.pem',
                        '-days', '365', '-nodes',
                        '-subj', '/C=PL/ST=Mazowieckie/L=Warsaw/O=Tesla Monitor/CN=localhost',
                        '-addext', 'subjectAltName=DNS:localhost,IP:127.0.0.1'
                    ], check=True, capture_output=True, text=True)
                    logger.info("‚úÖ Certyfikaty TLS wygenerowane pomy≈õlnie")
                except subprocess.CalledProcessError as cert_error:
                    logger.error(f"‚ùå B≈ÇƒÖd generowania certyfikat√≥w TLS: {cert_error}")
                    logger.error(f"stdout: {cert_error.stdout}")
                    logger.error(f"stderr: {cert_error.stderr}")
                    return False
            
            # Sprawd≈∫ czy tesla-http-proxy jest dostƒôpny
            try:
                result = subprocess.run(['tesla-http-proxy', '--help'], 
                                      capture_output=True, text=True, timeout=5)
                logger.info("‚úÖ tesla-http-proxy jest dostƒôpny")
            except subprocess.TimeoutExpired:
                logger.error("‚ùå tesla-http-proxy timeout - mo≈ºe byƒá zawieszony")
                return False
            except FileNotFoundError:
                logger.error("‚ùå tesla-http-proxy nie znaleziony w PATH")
                logger.error("üí° Sprawd≈∫ czy tesla-http-proxy jest zainstalowany")
                return False
            except Exception as proxy_check_error:
                logger.error(f"‚ùå B≈ÇƒÖd sprawdzania tesla-http-proxy: {proxy_check_error}")
                return False
            
            # Uruchom Tesla HTTP Proxy
            proxy_cmd = [
                'tesla-http-proxy',
                '-tls-key', 'tls-key.pem',
                '-cert', 'tls-cert.pem',
                '-port', proxy_port,
                '-host', proxy_host,
                '-key-name', 'tesla-fleet-api',
                '-keyring-type', 'file',
                '-key-file', 'private-key.pem',
                '-verbose'  # NAPRAWKA: Dodaj verbose dla lepszego debugowania
            ]
            
            logger.info(f"üîß Komenda proxy: {' '.join(proxy_cmd)}")
            
            self.proxy_process = subprocess.Popen(
                proxy_cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                text=True
            )
            
            logger.info(f"‚è≥ Oczekiwanie na uruchomienie proxy (PID: {self.proxy_process.pid})...")
            
            # Poczekaj na uruchomienie proxy z progressivnym timeout'em
            for attempt in range(1, 11):  # 10 pr√≥b
                time.sleep(1)
                
                # Sprawd≈∫ czy proces nadal dzia≈Ça
                if self.proxy_process.poll() is not None:
                    # Proxy siƒô zatrzyma≈Ç
                    stdout, stderr = self.proxy_process.communicate()
                    logger.error(f"‚ùå Tesla HTTP Proxy zatrzyma≈Ç siƒô podczas startu (pr√≥ba {attempt})")
                    logger.error(f"stdout: {stdout}")
                    logger.error(f"stderr: {stderr}")
                    return False
                
                # Test po≈ÇƒÖczenia
                if self._test_proxy_connection():
                    self.proxy_running = True
                    logger.info(f"‚úÖ Tesla HTTP Proxy uruchomiony pomy≈õlnie po {attempt}s (PID: {self.proxy_process.pid})")
                    
                    # Dodatkowy test autoryzacji
                    try:
                        proxy_url = f"https://{proxy_host}:{proxy_port}"
                        response = requests.get(f"{proxy_url}/api/1/vehicles", 
                                              timeout=5, verify=False)
                        logger.info(f"üîó Test autoryzacji proxy: status {response.status_code}")
                    except Exception as auth_test_error:
                        logger.debug(f"Test autoryzacji b≈ÇƒÖd: {auth_test_error}")
                    
                    return True
                
                if attempt % 3 == 0:  # Co 3 sekundy
                    logger.info(f"‚è≥ Pr√≥ba {attempt}/10 - czekam na odpowied≈∫ proxy...")
            
            # Timeout - proxy nie odpowiada
            logger.error("‚ùå Tesla HTTP Proxy nie odpowiada po 10 sekundach")
            
            # Sprawd≈∫ czy proces jeszcze dzia≈Ça
            if self.proxy_process.poll() is None:
                logger.error("üîç Proces proxy dzia≈Ça ale nie odpowiada - sprawdzam logi...")
                # Spr√≥buj odczytaƒá partial output
                try:
                    stdout, stderr = self.proxy_process.communicate(timeout=2)
                    if stdout:
                        logger.error(f"stdout: {stdout[:500]}...")
                    if stderr:
                        logger.error(f"stderr: {stderr[:500]}...")
                except subprocess.TimeoutExpired:
                    logger.error("‚è∞ Nie mo≈ºna odczytaƒá log√≥w proxy - timeout")
            
            self._stop_proxy()
            return False
                
        except subprocess.SubprocessError as e:
            logger.error(f"‚ùå B≈ÇƒÖd uruchamiania Tesla HTTP Proxy: {e}")
            return False
        except Exception as e:
            logger.error(f"üí• Nieoczekiwany b≈ÇƒÖd uruchamiania proxy: {e}")
            import traceback
            logger.error(f"Stack trace: {traceback.format_exc()}")
            return False
    
    def _stop_proxy(self):
        """Zatrzymuje Tesla HTTP Proxy"""
        if self.proxy_process and self.proxy_process.poll() is None:
            try:
                self.proxy_process.terminate()
                self.proxy_process.wait(timeout=10)
                logger.info("üõë Tesla HTTP Proxy zatrzymany")
            except subprocess.TimeoutExpired:
                self.proxy_process.kill()
                logger.warning("‚ö†Ô∏è Tesla HTTP Proxy zabity (timeout)")
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd zatrzymywania proxy: {e}")
        
        self.proxy_running = False
        self.proxy_process = None
        
        # Wyczy≈õƒá certyfikaty TLS
        try:
            if os.path.exists('tls-key.pem'):
                os.remove('tls-key.pem')
            if os.path.exists('tls-cert.pem'):
                os.remove('tls-cert.pem')
        except Exception as e:
            logger.debug(f"B≈ÇƒÖd czyszczenia certyfikat√≥w: {e}")
    
    def _test_proxy_connection(self) -> bool:
        """
        Testuje po≈ÇƒÖczenie z Tesla HTTP Proxy
        
        Returns:
            bool: True je≈õli proxy odpowiada
        """
        try:
            import requests
            
            proxy_host = os.getenv('TESLA_HTTP_PROXY_HOST', 'localhost')
            proxy_port = os.getenv('TESLA_HTTP_PROXY_PORT', '4443')
            proxy_url = f"https://{proxy_host}:{proxy_port}"
            
            # Test po≈ÇƒÖczenia z timeout'em i bez weryfikacji SSL (self-signed cert)
            response = requests.get(
                f"{proxy_url}/api/1/vehicles",
                timeout=10,
                verify=False  # Tesla HTTP Proxy u≈ºywa self-signed cert
            )
            
            if response.status_code in [200, 401, 403]:  # 200=OK, 401/403=auth error ale proxy dzia≈Ça
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Tesla HTTP Proxy niespodziewany status: {response.status_code}")
                return False
                
        except requests.exceptions.ConnectionError:
            return False
        except requests.exceptions.Timeout:
            return False
        except Exception as e:
            logger.debug(f"B≈ÇƒÖd testowania proxy: {e}")
            return False

    def _test_tesla_proxy_connection(self, proxy_host: str, proxy_port: str):
        """
        Testuje po≈ÇƒÖczenie z Tesla HTTP Proxy
        
        Args:
            proxy_host: Host proxy (np. localhost)
            proxy_port: Port proxy (np. 4443)
        """
        try:
            import requests
            import ssl
            
            proxy_url = f"https://{proxy_host}:{proxy_port}"
            logger.info(f"üîó Testujƒô po≈ÇƒÖczenie z Tesla HTTP Proxy: {proxy_url}")
            
            # Test po≈ÇƒÖczenia z timeout'em i bez weryfikacji SSL (self-signed cert)
            response = requests.get(
                f"{proxy_url}/api/1/vehicles",
                timeout=10,
                verify=False  # Tesla HTTP Proxy u≈ºywa self-signed cert
            )
            
            if response.status_code in [200, 401, 403]:  # 200=OK, 401/403=auth error ale proxy dzia≈Ça
                logger.info(f"‚úÖ Tesla HTTP Proxy odpowiada (status: {response.status_code})")
                if response.status_code == 401:
                    logger.info("üîê Tesla HTTP Proxy wymaga autoryzacji - to normalne")
            else:
                logger.warning(f"‚ö†Ô∏è Tesla HTTP Proxy niespodziewany status: {response.status_code}")
                
        except requests.exceptions.ConnectionError as e:
            logger.error(f"‚ùå Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z Tesla HTTP Proxy: {e}")
            logger.error(f"üí° Sprawd≈∫ czy Tesla HTTP Proxy jest uruchomiony na {proxy_host}:{proxy_port}")
        except requests.exceptions.Timeout:
            logger.error(f"‚è∞ Timeout po≈ÇƒÖczenia z Tesla HTTP Proxy (10s)")
        except Exception as e:
            logger.error(f"üí• B≈ÇƒÖd testowania Tesla HTTP Proxy: {e}")

    def _get_firestore_client(self):
        """Zwraca klienta Firestore dla Worker Service"""
        return self.firestore_client



    def _remove_old_schedules_from_tesla(self, old_schedules: List[Dict], vehicle_vin: str) -> bool:
        """
        Usuwa konkretne harmonogramy ≈Çadowania z pojazdu Tesla
        NOWA WERSJA: bez logiki charge_stop - usuwa tylko podane harmonogramy
        
        Args:
            old_schedules: Lista starych harmonogram√≥w do usuniƒôcia
            vehicle_vin: VIN pojazdu
            
        Returns:
            bool: True je≈õli usuniƒôto wszystkie harmonogramy pomy≈õlnie
        """
        try:
            if not old_schedules:
                logger.info(f"üìç Brak harmonogram√≥w do usuniƒôcia dla {vehicle_vin[-4:]}")
                return True
            
            # Usu≈Ñ podane harmonogramy
            logger.info(f"üóëÔ∏è Usuwanie {len(old_schedules)} starych harmonogram√≥w...")
            success_count = 0
            
            for schedule in old_schedules:
                schedule_id = schedule.get('id')
                if schedule_id:
                    logger.info(f"üóëÔ∏è Pr√≥ba usuniƒôcia starego harmonogramu ID: {schedule_id}")
                    
                    # Wy≈õwietl szczeg√≥≈Çy harmonogramu przed usuniƒôciem
                    start_time = schedule.get('start_time', 'N/A')
                    end_time = schedule.get('end_time', 'N/A')
                    enabled = schedule.get('enabled', False)
                    logger.info(f"üìã Stary harmonogram {schedule_id}: {start_time}-{end_time}, enabled={enabled}")
                    
                    try:
                        if self.tesla_controller.remove_charge_schedule(schedule_id):
                            success_count += 1
                            logger.info(f"‚úÖ Usuniƒôto stary harmonogram ID: {schedule_id}")
                        else:
                            logger.error(f"‚ùå B≈ÇƒÖd usuwania starego harmonogramu ID: {schedule_id}")
                            
                            # Sprawd≈∫ czy harmonogram nadal istnieje
                            current_schedules = self._get_home_schedules_from_tesla(vehicle_vin)
                            still_exists = any(s.get('id') == schedule_id for s in current_schedules)
                            if still_exists:
                                logger.error(f"üîç Stary harmonogram {schedule_id} nadal istnieje w Tesla")
                            else:
                                logger.info(f"ü§î Stary harmonogram {schedule_id} nie istnieje w Tesla - mo≈ºe zosta≈Ç ju≈º usuniƒôty")
                                success_count += 1  # Traktuj jako sukces
                            
                    except Exception as remove_error:
                        logger.error(f"üí• WyjƒÖtek podczas usuwania starego harmonogramu ID {schedule_id}: {remove_error}")
                        logger.error(f"üí° Typ b≈Çƒôdu: {type(remove_error).__name__}")
                        
                        # Sprawd≈∫ czy to b≈ÇƒÖd autoryzacji
                        if "401" in str(remove_error) or "unauthorized" in str(remove_error).lower():
                            logger.error(f"üö´ B≈ÇƒÖd autoryzacji - sprawd≈∫ tokeny Tesla")
                        elif "412" in str(remove_error) or "not supported" in str(remove_error).lower():
                            logger.error(f"üö´ Komenda nie obs≈Çugiwana - sprawd≈∫ czy Tesla HTTP Proxy dzia≈Ça")
                        elif "timeout" in str(remove_error).lower():
                            logger.error(f"‚è∞ Timeout - Tesla API mo≈ºe byƒá przeciƒÖ≈ºone")
                else:
                    logger.error(f"‚ùå Stary harmonogram bez ID - pomijam")
            
            logger.info(f"üóëÔ∏è Usuniƒôto {success_count}/{len(old_schedules)} starych harmonogram√≥w")
            
            # Je≈õli nie uda≈Ço siƒô usunƒÖƒá wszystkich, ale uda≈Ço siƒô przynajmniej czƒô≈õƒá
            if success_count > 0 and success_count < len(old_schedules):
                logger.warning(f"‚ö†Ô∏è Czƒô≈õciowy sukces usuwania starych harmonogram√≥w ({success_count}/{len(old_schedules)})")
                
            return success_count == len(old_schedules)
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd usuwania starych harmonogram√≥w: {e}")
            return False

def main():
    """G≈Ç√≥wna funkcja uruchamiajƒÖca monitor"""
    logger.info("üöÄ === URUCHAMIANIE TESLA MONITOR ===")
    
    try:
        logger.info("üèóÔ∏è Tworzenie instancji CloudTeslaMonitor...")
        monitor = CloudTeslaMonitor()
        logger.info("‚úÖ Instancja CloudTeslaMonitor utworzona pomy≈õlnie")
    except Exception as init_error:
        logger.error(f"üí• KRYTYCZNY b≈ÇƒÖd tworzenia monitora: {init_error}")
        logger.error(f"üí• Typ b≈Çƒôdu: {type(init_error).__name__}")
        import traceback
        logger.error(f"üí• Stack trace: {traceback.format_exc()}")
        return 1
    
    try:
        logger.info("‚ñ∂Ô∏è Rozpoczynam monitoring...")
        monitor.start_monitoring()
        logger.info("‚úÖ Monitoring zako≈Ñczony normalnie")
    except Exception as e:
        logger.error(f"üí• KRYTYCZNY b≈ÇƒÖd uruchamiania monitora: {e}")
        logger.error(f"üí• Typ b≈Çƒôdu: {type(e).__name__}")
        import traceback
        logger.error(f"üí• Stack trace: {traceback.format_exc()}")
        return 1
    
    logger.info("üèÅ === KONIEC TESLA MONITOR ===")
    return 0

if __name__ == "__main__":
    try:
        logger.info("üé¨ === URUCHAMIANIE G≈Å√ìWNEJ FUNKCJI ===")
        exit_code = main()
        logger.info(f"üèÅ Aplikacja ko≈Ñczy dzia≈Çanie z kodem: {exit_code}")
        
        # Loguj dlaczego aplikacja siƒô ko≈Ñczy
        import traceback
        logger.info("üîç Aplikacja ko≈Ñczy siƒô z:")
        for line in traceback.format_stack():
            logger.info(f"üîç   {line.strip()}")
            
        logger.info(f"‚ö° Wywo≈Çujƒô exit({exit_code})")
        exit(exit_code)
    except Exception as final_error:
        logger.error(f"üí• FINA≈ÅOWY b≈ÇƒÖd aplikacji: {final_error}")
        import traceback
        logger.error(f"üí• Stack trace: {traceback.format_exc()}")
        logger.info("‚ö° Wywo≈Çujƒô exit(1) przez b≈ÇƒÖd")
        exit(1) 